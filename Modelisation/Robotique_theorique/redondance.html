<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Robotique Th√©orique</title>
  <link rel="stylesheet" href="/style.css">
</head>
<body>

  <!-- Navbar dynamique -->
  <div id="navbar"></div>

  <!-- --- MathJax for LaTeX equations --- -->
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>

  <script>
  // Load navbar dynamically from external file
  fetch("/navbar.html")
    .then(response => response.text())  // Read the content as text
    .then(data => {
      // Insert the navbar HTML into the page
      document.getElementById("navbar").innerHTML = data;

      // ----------------------------
      // Highlight the current page
      // ----------------------------
      const currentPath = window.location.pathname;  // e.g., "/index.html"
      const links = document.querySelectorAll("#navbar nav a"); // all nav links

      links.forEach(link => {
        const href = link.getAttribute("href");
        if (!href) return; // Skip links without href

        // Normalize paths (remove leading slash) to compare properly
        const normalizedHref = href.replace(/^\//, "");
        const normalizedPath = currentPath.replace(/^\//, "");

        if (normalizedPath.endsWith(normalizedHref)) {
          // ‚úÖ Mark link of current page as active
          link.classList.add("active");

          // If the link is in a submenu, also highlight its parent
          const parentLi = link.closest("ul")?.closest("li");
          if (parentLi) {
            const parentLink = parentLi.querySelector(":scope > a");
            if (parentLink) parentLink.classList.add("active-parent");
          }
        } else {
          // Remove active class from other links
          link.classList.remove("active");
        }
      });

      // ----------------------------
      // Night mode toggle button
      // ----------------------------
      const themeToggle = document.getElementById("themeToggle");

      // On page load, check if user previously enabled night mode
      if (localStorage.getItem("nightMode") === "true") {
        document.body.classList.add("night");
        if (themeToggle) themeToggle.textContent = "‚òÄÔ∏è Day Mode";
      }

      // Set up click listener for the button
      if (themeToggle) {
        themeToggle.addEventListener("click", () => {
          document.body.classList.toggle("night"); // Toggle night mode

          // Save current mode in localStorage to persist across pages
          const isNight = document.body.classList.contains("night");
          localStorage.setItem("nightMode", isNight);

          // Update button text based on current mode
          themeToggle.textContent = isNight ? "‚òÄÔ∏è Day Mode" : "üåô Night Mode";
        });
      }
    })
    .catch(error => console.error("Erreur chargement navbar :", error));
</script>


  <div class="container">
    <!-- Sidebar gauche -->
    <aside class="sidebar">
      <h3>Robotique Th√©orique</h3>
      <ul>
        <li><a href="/Modelisation/Robotique_theorique/Transformation_homogene.html">Transformation Homog√®ne</a></li>
        <li><a href="/Modelisation/Robotique_theorique/mgd_mgi_6axes.html">R√©solution MGD & MGI seriel</a></li>
        <li><a href="/Modelisation/Robotique_theorique/convention_DH.html">Convention DH</a></li>
        <li><a href="/Modelisation/Robotique_theorique/generation_mouvement.html">G√©n√©ration de mouvement</a></li>
        <li><a href="/Modelisation/Robotique_theorique/jacobienne_manipulabilite.html" >Jacobienne</a></li>
        <li><a href="/Modelisation/Robotique_theorique/redondance.html" class="active">Redondance</a></li>
      </ul>
      </ul>
    </aside>

    <!-- Contenu principal -->
    <main class="content">
        <h1>Principe de redondance</h1>

        <p>
             En robotique, la redondance d√©signe le fait qu‚Äôun robot poss√®de plus de degr√©s
             de libert√© que n√©cessaire pour accomplir une t√¢che donn√©e. Cette surabondance
             de mouvements possibles lui permet d‚Äôatteindre le m√™me objectif de plusieurs
             fa√ßons diff√©rentes. Elle est utile pour √©viter les obstacles, am√©liorer la 
             pr√©cision, optimiser l‚Äô√©nergie consomm√©e, √©viter les configurations singuli√®res
             ou encore tenir compte de contraintes suppl√©mentaires, tout en maintenant la
             position ou l‚Äôorientation souhait√©e de l‚Äôoutil.
        </p>

     

        <div class="highlight">
            <p>
                On retrouve une abondance de robot redondant dans la recherche (robot humanoide...), mais aussi sur des lignes
                de production o√π ils font la soudure ou encore dans la robotique m√©dicale 
                o√π la redondance facilite le contact avec l'Homme
            </p>
        </div>


        <p>
            Cette redondance peut se traduire par des articulations suppl√©mentaires comme 
            une articulation suppl√©mentaire, ou par des dispositifs plus 
            globaux comme une grosse glissi√®re au sol qui d√©place tout le robot.
        </p>

        <hr>

        <h3> Adaptation des calculs</h3>

        <p>
            Si la redondance est extremement utile pour certaine utilisation elle n√©c√©ssite
            de s'y adapter du cot√© software. <br>
            En effet, comme expliqu√© plus haut, avoir plusieurs solution pour une tache donn√©e fait que le
            MGI n'est plus solvable. Avoir plusieur choix est un avantage mais cela nous oblige √† choisir 
            une solution, ce qui peut √™tre complexe. Le MGD quant √† lui reste inchang√©.
        </p>

        <b>MGI Num√©rique</b>

        <p>
            Pour r√©soudre ce probl√®me on utilise l'algorithme MGI Num√©rique (de Newton-Raphson).
        </p>

        <p>
            Le principe ressemble √† la r√©solution d'un polynome de degr√©s 3 par it√©ration
        </p>

        <p>
            On consid√®re un robot √† <em>n</em> articulations d√©crites par les coordonn√©es articulaires.
            Le MGI num√©rique consiste √† r√©soudre pour \(q\) l'√©quation non lin√©aire :
        
            \[ f(q)= x_d, \]
        </p>
        <p>
            o√π \(x_d\) est la pose d√©sir√©e. On d√©finit l'erreur :
            \[ e(q) = x_d - f(q). \]
        </p>

      <p>
        Le probl√®me de l‚Äôinversion revient alors √† trouver un z√©ro de cette fonction d‚Äôerreur. 
      </p>

      <p>
        Partant d‚Äôun point \(q_0\) (de pr√©f√©rence proche du z√©ro √† trouver), 
        la m√©thode consiste √† une approximation affine \(p\) de \(e\) autour du point \(q_0\) 
        √† l‚Äôaide de son d√©veloppement de Taylor au premier ordre :
      </p>

      <p>
      \[
      p(q) = e(q_0) + J(q_0) \cdot (q - q_0)
      \]
      </p>

      <p>
        avec \(J(q_0)\) la matrice jacobienne de la fonction \(e\). La jacobienne de \(e\)
         est identique √† celle de \(f\) puisque \(x^*\) est constant.
      </p>

      <p>
        On calcule alors un nouveau point \(q_1\) solution de l‚Äô√©quation :
      </p>

      <p>
      \[
      e(q_0) + J(q_0) \cdot (q - q_0) = 0
      \]
      </p>

      <p>Soit :</p>

      <p>
      \[
      q_1 = q_0 - [J(q_0)]^{-1} \cdot e(q_0)
      \]
      </p>

      <p>Sous certaines hypoth√®ses, le point \(q_1\) sera plus proche du vrai z√©ro de \(e\) que le point \(q_0\) pr√©c√©dent.</p>

      <p>On peut ensuite r√©it√©rer le processus, c‚Äôest-√†-dire d√©finir \(q_{k+1}\) comme la solution de l‚Äô√©quation :</p>

      <p>
      \[
      e(q_k) + J(q_k) \cdot (q - q_k) = 0
      \]
      </p>

      <p>soit en rempla√ßant la fonction \(e\) :</p>

      <p>
      \[
      x^* - f(q_k) + J(q_k) \cdot (q - q_k) = 0
      \]
      </p>

      <p>Ce qui correspond √† d√©finir la r√©currence suivante :</p>

      <p>
      \[
      q_{k+1} = q_k - [J(q_k)]^{-1} \cdot (f(q_k) - x^*)
      \]
      </p>


       
        <hr>
        <h3>Amortissement et gestion des singularit√©s</h3>

        <p>
            Pour √©viter les probl√®mes num√©riques quand \(\ J J^T\) est mal conditionn√©, on utilise souvent une version amortie :
        </p>

        <p>
            \[ J^+ = (\ J J^T + \lambda^2 I)^{-1}J^T. \]

        </p>
        
        <p>
            Le param√®tre \(\lambda\) sert √† stabiliser le calcul de l‚Äôinverse
            lorsque \(J J^T\) est presque singulier, c‚Äôest-√†-dire que certaines directions de 
            l‚Äôespace sont tr√®s ‚Äúplates‚Äù et pourraient amplifier les erreurs num√©riques. 
            Sans \(\lambda\), on utiliserait simplement le pseudo-inverse classique,
            mais si \(J J^T\) a des valeurs propres tr√®s petites, l‚Äôinversion devient instable et bruit√©e.
        </p>

        <p>
            Ajouter \(\lambda^2 I\) revient √† amortir les petites valeurs propres, ce qui rend la matrice plus robuste √† l‚Äôinversion. En pratique :
            <ul>
                <li>Pseudo-inverse classique : sensible aux directions presque singuli√®res ‚Üí grosses erreurs possibles.</li>
                <li>Version amortie (ou damped) : contr√¥le la sensibilit√© ‚Üí mouvement plus stable et r√©gulier.</li>
            </ul>
        </p>

        <p>
            Cela correspond √† la m√©thode dite <em>Moore-Penrose r√©gularis√©</em> ou 
            <em>Damped Least Squares</em> (DLS), tr√®s utile pour les robots redondants ou
            lorsque les articulations sont proches de leurs limites.
        </p>

        <hr>
        <h3>
            Null Space Projection
        </h3>


        <p>
            Cependant, le syst√®me ne converge pas n√©cessairement vers la "meilleure solution" 
            ou celle que l'on voudrait. La solution finale d√©pend fortement du guess initial.
        </p>

        <p>
            Ainsi il est int√©rressant de r√©ussir √† influencer le robot √† "choisir" une solution qui favorise
            par exmeple une solution fluide, ou qui reste dans les limite angulaire, de vitesse... 
        </p>

        <p>
            Pour ce faire on utilise une matrice de Null Space Projection que l'on note \(N\) tel que :

            \[
            N = I - J^+ J.
            \]
        </p>

        <p>
            La matrice \(N\) projette n‚Äôimporte quel vecteur dans le <em>null space</em>
            de la t√¢che principale. Concr√®tement, cela signifie que si vous appliquez un 
            mouvement dans la direction \(N v\) (pour un vecteur \(v\) quelconque), 
            ce mouvement n‚Äôaffectera pas la r√©alisation de la t√¢che principale. 
        </p>

        <p>
            En d‚Äôautres termes :
            <ul>
                <li>\(J^+ J\) repr√©sente la partie du mouvement qui contribue √† la t√¢che principale.</li>
                <li>\(I - J^+ J = N\) correspond √† la partie ‚Äúlibre‚Äù qui ne modifie pas la t√¢che principale.</li>
            </ul>
        </p>

        <p>
          Ainsi on a finalement :
          \[ \Delta q = J^+e + \alpha Nv, \] 
          o√π \(v \) est un vecteur choisi pour satisfaire un crit√®re secondaire, et \(\alpha \)
          est un facteur d'√©chelle pour ajuster l'influence du null space
        </p>


        <hr>
        <h3>
            Exemple de code
        </h3>

        <p>
            Voici les codes pour manipuler les notions pr√©sent√©es plus haut.

            <div class="highlight">
              <p>
                Les param√®tres important sont surtout \(\alpha \), \(\lambda \) et la tolerance. Une petite 
                modification change drastiquement la trajectoire et plus g√©n√©ralement si la solutions
                converge. <br>
                Il est <b>tr√®s facile</b> de diverger si on joue avec \(N \) de mani√®re g√©n√©rale !  
              </p>

            </div>
        </p>

        <img src="/Modelisation/Robotique_theorique/redondance_GIF.gif" alt="Animation GIF" style="max-width:400px;">

            <details >
    <summary > <b style="color: red;">MGI Num√©rique sur Python</b> 
        </summary >
    <pre><button class="copy-btn" onclick="copyCode()">Copier</button><code id="code-block">
import numpy as np
np.set_printoptions(precision=4, suppress=True, floatmode='fixed')

# m√™me MGD que dans les autres cours adapt√© pour le PA10, 7 axes
def MGD_7dof(q_i):

    DH7_parameters = np.array([
    [ 0,       0,   q_i[0], 0.317],
    [-np.pi/2, 0,   q_i[1], 0    ],
    [ np.pi/2, 0,   q_i[2], 0.45 ],
    [-np.pi/2, 0,   q_i[3], 0    ],
    [ np.pi/2, 0,   q_i[4], 0.48 ],
    [-np.pi/2, 0,   q_i[5], 0    ],
    [ np.pi/2, 0,   q_i[6], 0.07 ]
    ])

    def DH_M(alpha, a, theta, d):

        ct = np.cos(theta)
        st = np.sin(theta)
        ca = np.cos(alpha)
        sa = np.sin(alpha)
        
        return np.array([
            [ct,    -st,      0,      a  ],
            [st*ca, ct*ca,  -sa,    -sa*d],
            [st*sa, ct*sa,   ca,     ca*d],
            [0,       0,      0,      1  ]
        ])
    

    T = np.eye(4)
    T_tot = [np.eye(4)] 

    for i in range(DH7_parameters.shape[0]): 
        alpha, a, theta, d = DH7_parameters[i]
        Ti = DH_M(alpha, a, theta, d)
        T = T @ Ti
        T_tot.append(T)  


    position_effecteur = T[:3, 3]

    rota_y =  np.arcsin(-T[2,0])
    if abs(np.cos(rota_y)) > 1e-6:
            rota_x = np.arctan2(T[2, 1], T[2, 2]) 
            rota_z = np.arctan2(T[1, 0], T[0, 0]) 
    else:
            # Cas singulier : Œ∏ ‚âà 0 ou œÄ
            rota_z = np.arctan2(-T[0, 1], T[1, 1])
            rota_x = 0.0

    #autres solutions valide d'identification de ZYX 
    #q[4] = np.pi - q[4]
    #q[3] = q[3] + np.pi
    #q[5] = q[5] + np.pi


    
    position_final = [position_effecteur[0],position_effecteur[1],position_effecteur[2],rota_x,rota_y,rota_z]

    # return aussi les Ti pour les plots plus bas et la jacobienne
    return position_final, T_tot


# De m√™me, jacobienne adapt√©e au PA10-7c
def Jacobian_geometrical_7dof(q):

    xf , Mtot = MGD_7dof(q)

    Jc = np.zeros((6, 7))

    for i in range(7):
        
        T =  Mtot[i+1]          # /!\ i+1 avec convention DHM /!\
        position = T[0:3, 3]    
        Ui = T[0:3, 2]          # toujours axe Z_i avec la convention DH  

        Jc[3:6, i] = Ui

        Jv = np.cross(Ui, xf[:3] - position)

        Jc[0:3, i] = Jv

    return Jc



def MGI_NUM(xf, initial_guess):
    i=0     # simplement pour savoir ou on en est dans le calcul (peut etre long)
    qi_num = initial_guess.astype(float) 
    ite_max = 20000 
    tolerance = 1e-5        #les 3 param√®tres on une influence enorme sur si cela converge ou pas
    lam = 0.05          
    alpha = 0.001

    lb_an = np.array([-177,-94,-174,-137,-255,-165,-255]) # limite articulaire haute et basse en degr√© du PA10 
    ub_an = np.array([177,94,174,137,255,165,255]) 

    lb_an = (lb_an * np.pi) / 180 # on convertis en radians
    ub_an = (ub_an * np.pi) / 180

    while i < ite_max:
        i += 1
        current_pos,_ = MGD_7dof(qi_num)
        erreur = xf - current_pos

        if np.linalg.norm(erreur) < tolerance:
            print(f"Converg√© en {i} iterations")
            break

        J = Jacobian_geometrical_7dof(qi_num)
        DLS_J =  np.linalg.inv(J.T @ J + lam**2 * np.eye(7)) @ J.T # calcul jacobienne DLS

        N = np.eye(7) - DLS_J @ J # la null space matrice

        # pour rester dans les limites articulaires
        #w = -lam * (qi_num - lb_an) * (qi_num < lb_an) - lam * (qi_num - ub_an) * (qi_num > ub_an) # vetceur objectif secondaire

        v = np.zeros(7)  # vecteur secondaire

        # Forcer l'utilisation de la redondance
        if abs(v[2]) < 0.1:
            v[2] = +0.1   # pousse q3 vers la limite haute
        else:
            v[2] = -0.1   # pousse q3 vers la limite basse

        # Appliquer dans la mise √† jour MGI num√©rique avec gain alpha

        qi_num += DLS_J @ erreur + alpha * (N @ v) #+ alpha * (N @ w)

 

    if i == ite_max: 
         print("Attention: iteration maximum atteint sans avoir la tolerance.") 
    return qi_num

      

        </code></pre>
    </details>

     <details >
    <summary > <b style="color: red;">Repr√©sentation Trajectoire avec le MGI num√©rique sur Python</b> 
        </summary >
    <pre><button class="copy-btn" onclick="copyCode()">Copier</button><code id="code-block">
import numpy as np
import matplotlib.pyplot as plt
from MGI_num import *


#meme genberation de points que pour une ligne en 6axes
freq_sample = 200       # nombre d‚Äô√©chantillons
temps_ini = 0.0        
temps_fin = 2.0          

positions_xyz = []
positions_qi = []

# position dans l'espace operationel 
position_fin = np.array([-0.5,0,0.7,0,0,0])
position_ini = np.array([0.5,0,0.3,0,0,0])

# distance de d√©placement 
deplacement = position_fin - position_ini
norme_eucli = np.linalg.norm(deplacement)

# vecteur direction normalis√© (ligne droite de A √† B)
vecteur_p = deplacement / norme_eucli

# instants d‚Äô√©chantillonnage
echantillonage = np.linspace(temps_ini, temps_fin, freq_sample)


# param√®tre quintique
T = temps_fin - temps_ini
a = 6 * norme_eucli / T**5 # norm_eucli pour normaliser la direction du mouvement
b = -15 * norme_eucli / T**4
c = 10 * norme_eucli / T**3



# le qi_guess np.zeros(7) marche la pluspart du temps mais toujours mieux de calculer le 1er
# avec des parametre facil et update ici pour faciliter le calcul du 1er
qi_guess = np.array([-0.4179 , 2.7490 , 2.6607 , 1.9887 ,-2.8963 ,-0.8163, -0.2011])


i=0
for t in echantillonage:
    i +=1
    print(i)
    # loi temporelle 
    s = a*t**5 + b*t**4 + c*t**3 # valeur entre 0 et 1 (equivalent √† pourcentage de progression)

    pt = position_ini + s * vecteur_p
    positions_xyz.append(pt)


    # cin√©matique inverse delta ‚Üí calcul des q_i pour les plots avec mgi num√©rique
    qi = MGI_NUM(pt,qi_guess)
    qi_guess = qi #on prend la valeur d'avant pour √™tre sur d'√™tre proche d'une solution
    
    positions_qi.append(qi) #sauvegarde valeurs


# conversion en tableau numpy pour plot
positions_qi = np.array(positions_qi)



# ----------------- Calcul de dq & ddq -----------------
dt = echantillonage[1] - echantillonage[0]
dq = np.gradient(positions_qi, dt, axis=0)
ddq = np.gradient(dq, dt, axis=0)


# difference consecutive entre les qi 
dq_sum = np.diff(positions_qi, axis=0)  

#on fait la somme
cumulative_distance_per_joint = np.sum(np.abs(dq_sum), axis=0) 
print("deplacement total en rad des qi =",cumulative_distance_per_joint)

# =====================
# PLOT Q 
# =====================
plt.figure(figsize=(10,6))
for i in range(7):
    plt.plot(echantillonage, positions_qi[:, i], label=f'q{i+1}', linewidth=2)

plt.xlabel('Temps [s]')
plt.ylabel('Angle [rad]')
plt.title('√âvolution des articulations')
plt.grid(True, linestyle='--', alpha=0.5)
plt.tight_layout()
plt.legend()
plt.grid(True)
plt.show()

# ----------------- PLOT DQ -----------------
plt.figure(figsize=(10,6))
for i in range(7):
    plt.plot(echantillonage, dq[:, i], label=f'dq{i+1}')
plt.xlabel('Time [s]')
plt.ylabel('Velocity [rad/s]')
plt.title('Joint Velocities dq_i')
plt.grid(True, linestyle='--', alpha=0.5)
plt.legend()
plt.show()

# ----------------- PLOT DDQ -----------------
plt.figure(figsize=(10,6))
for i in range(7):
    plt.plot(echantillonage, ddq[:, i], label=f'ddq{i+1}')
plt.xlabel('Time [s]')
plt.ylabel('Acceleration [rad/s¬≤]')
plt.title('Joint Accelerations ddq_i')
plt.grid(True, linestyle='--', alpha=0.5)
plt.legend()
plt.show()

#============================================
 # Animation avec un plot du 7 axes et de la traj 
#============================================
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')

ax.set_xlim(-1,1)
ax.set_ylim(-1,1)
ax.set_zlim(0,1.5)
ax.set_box_aspect([1,1,1])
ax.set_xlabel("X")
ax.set_ylabel("Y")
ax.set_zlabel("Z")
ax.set_title("7-DOF Robot Animation")

robot_line, = ax.plot([], [], [], '-o', markersize=6, linewidth=2)

positions_xyz = np.array(positions_xyz)

ax.scatter(
    positions_xyz[:,0],
    positions_xyz[:,1],
    positions_xyz[:,2],
    c=range(len(positions_xyz)),
    s=10
)

for q in positions_qi:  

    _, T_tot = MGD_7dof(q)
    
    points = np.array([T[:3,3] for T in T_tot])  

    xs = points[:,0]
    ys = points[:,1]
    zs = points[:,2]

    # update 
    robot_line.set_data(xs, ys)
    robot_line.set_3d_properties(zs)

    plt.draw()
    plt.pause(0.01)

    

        </code></pre>
    </details>
        

           <hr>
    <h3>
      Sources annexes :
    </h3>

    <p>
         <a href="https://gjlaurent.github.io/assets/cours/polyRobotiqueIndustrielle.pdf">Robotique industrielle de Guillaume Laurent & Nicolas Chaillet 2024</a> <br>
         <a href="https://www.youtube.com/@AlexandreGirard87">Chaine Youtube d'Alexandre Girard</a> <br>

    </p>

    </main>
</div>

<footer>
    ¬© 2025 - Guillaume Dengreville
</footer>

</body>
</html>