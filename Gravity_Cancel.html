<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Robotique Th√©orique</title>
  <link rel="stylesheet" href="/style.css">
</head>
<body>

  <!-- Navbar dynamique -->
  <div id="navbar"></div>

  <!-- --- MathJax for LaTeX equations --- -->
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>

  <script>
  // Load navbar dynamically from external file
  fetch("/navbar.html")
    .then(response => response.text())  // Read the content as text
    .then(data => {
      // Insert the navbar HTML into the page
      document.getElementById("navbar").innerHTML = data;

      // ----------------------------
      // Highlight the current page
      // ----------------------------
      const currentPath = window.location.pathname;  // e.g., "/index.html"
      const links = document.querySelectorAll("#navbar nav a"); // all nav links

      links.forEach(link => {
        const href = link.getAttribute("href");
        if (!href) return; // Skip links without href

        // Normalize paths (remove leading slash) to compare properly
        const normalizedHref = href.replace(/^\//, "");
        const normalizedPath = currentPath.replace(/^\//, "");

        if (normalizedPath.endsWith(normalizedHref)) {
          // ‚úÖ Mark link of current page as active
          link.classList.add("active");

          // If the link is in a submenu, also highlight its parent
          const parentLi = link.closest("ul")?.closest("li");
          if (parentLi) {
            const parentLink = parentLi.querySelector(":scope > a");
            if (parentLink) parentLink.classList.add("active-parent");
          }
        } else {
          // Remove active class from other links
          link.classList.remove("active");
        }
      });

      // ----------------------------
      // Night mode toggle button
      // ----------------------------
      const themeToggle = document.getElementById("themeToggle");

      // On page load, check if user previously enabled night mode
      if (localStorage.getItem("nightMode") === "true") {
        document.body.classList.add("night");
        if (themeToggle) themeToggle.textContent = "‚òÄÔ∏è Day Mode";
      }

      // Set up click listener for the button
      if (themeToggle) {
        themeToggle.addEventListener("click", () => {
          document.body.classList.toggle("night"); // Toggle night mode

          // Save current mode in localStorage to persist across pages
          const isNight = document.body.classList.contains("night");
          localStorage.setItem("nightMode", isNight);

          // Update button text based on current mode
          themeToggle.textContent = isNight ? "‚òÄÔ∏è Day Mode" : "üåô Night Mode";
        });
      }
    })
    .catch(error => console.error("Erreur chargement navbar :", error));
</script>


  <div class="container">
    

    <!-- Contenu principal -->
    <main class="content">
        
        <h1>
            Bras Robotique 2 axes : Annulation de la Gravit√©
        </h1>
       

        <p>
            Projet de robot 2 axes avec annulation de la gravit√© : il s‚Äôagit de 
            concevoir un syst√®me √† deux articulations capable de compenser en 
            temps r√©el l‚Äôeffet de la gravit√© afin de rendre la charge manipul√©e 
            ¬´ quasi-sans poids ¬ª ; le robot mesure la position des axes via des 
            codeurs, calcule les couples gravitationnels th√©oriques √† partir 
            d‚Äôun mod√®le simple des masses et longueurs des bras, puis commande 
            les moteurs pour appliquer des couples oppos√©s.
        </p>

        <div class="highlight">
        <p>
            On retrouve ce type de syst√®me dans plusieurs domaines : 
            dans l'industrie, pour les bras d‚Äôassistance √† l‚Äôop√©rateur 
            et les manipulateurs √©quilibr√©s qui permettent de porter 
            des charges sans effort.Dans la m√©decine pour la r√©√©ducation, dans 
            des dispositifs d‚Äôaide au mouvement  ou encore dans la recherche, 
            sur des bancs d‚Äôessai simulant l‚Äôapesanteur ou la dynamique 
            spatiale.
        </p>


        <img src="\Projet\exo_anti_gravite.png" alt="bras zero gravite">
            <div class="legend">
                    <p>Exosquelette Hercule de RB3D pour le militaire</p>
            </div> 

        </div>

        <p>
            Mon objectif √©tait de designer un bras robotique plannaire capable d'avoir un effet anti-gravit√©
            pour un poids en bout de bras allant jusqu'√† 1 Kg.
        </p>
        
        <hr>
        <h3>
        Mod√©lisation Th√©orique :
        </h3>

        <p>
            J'ai d√©ja discuter de la th√©orie pur sur l'√©quilibrage statique <br>
            Vous pouvez retrouver la page concern√© 
            <a href=\Modelisation\Robotique_theorique\jacobienne_manipulabilite.html> ici</a> 
        </p>

        <p>
            N√©anmoins voici le code scp√©cifique au robot :
        </p>

        <details >    
            <summary > <b style="color: red;">Equilibrage statique sur Python </b>
                </summary >
            <pre><button class="copy-btn" onclick="copyCode()">Copier</button><code id="code-block">    
import numpy as np
def equilibrageStatique(q2,q3,M,L1,L2):
    # Efforts dus √† la pesanteur et √©quilibrage statique
    # M est la masse ajout√© en bout de bras
    g = -9.81
    mbarre1=0.297*L1 #calcul de la masse des 2 barres
    mbarre2=0.136*L2
    masse = np.array([0.04+M+mbarre2, 0.158+mbarre1, 0])  # en kg
    q = np.array([0, q2, q3])

    tau_i = np.array([
        [0, 0, 0],
        [0, 0, 0],
        [masse[0] * g, masse[1] * g, masse[2] * g]
    ])

    l = np.array([0.2, L1+0.07, L2+0.045]) # Calcul de la longueur des bras
    # Calcul du centre de gravit√© √† l'aide de la m√©thode des barycentres
    lI= np.array([0.1, (L1*(0.087+mbarre1/2)+mbarre1*0.032+0.00696)/(0.158+mbarre1), ((0.033+L2)*(M+0.005)+0.00054+(0.028+L2/2)*mbarre2)/(M+mbarre2+0.03)])
   
    O0 = np.array([0, 0, 0])

    T01 = np.array([
        [np.cos(q[0]), -np.sin(q[0]), 0, 0],
        [np.sin(q[0]), np.cos(q[0]), 0, 0],
        [0, 0, 1, 0],
        [0, 0, 0, 1]
    ])

    T12 = np.array([
        [np.cos(q[1]), 0, np.sin(q[1]), 0],
        [0, 1, 0, 0],
        [-np.sin(q[1]), 0, np.cos(q[1]), l[0]],
        [0, 0, 0, 1]
    ])

    T12_CI = np.array([
        [np.cos(q[1]), 0, np.sin(q[1]), 0],
        [0, 1, 0, 0],
        [-np.sin(q[1]), 0, np.cos(q[1]), lI[0]],
        [0, 0, 0, 1]
    ])

    T02 = np.dot(T01, T12)
    T02_CI = np.dot(T01, T12_CI)

    T23 = np.array([
        [np.cos(q[2]), 0, np.sin(q[2]), 0],
        [0, 1, 0, 0],
        [-np.sin(q[2]), 0, np.cos(q[2]), l[1]],
        [0, 0, 0, 1]
    ])

    T23_CI = np.array([
        [np.cos(q[2]), 0, np.sin(q[2]), 0],
        [0, 1, 0, 0],
        [-np.sin(q[2]), 0, np.cos(q[2]), lI[1]],
        [0, 0, 0, 1]
    ])

    T03 = np.dot(T02, T23)
    T03_CI = np.dot(T02, T23_CI)

    T34 = np.array([
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, 1, l[2]],
        [0, 0, 0, 1]
    ])

    T34_CI = np.array([
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, 1, lI[2]],
        [0, 0, 0, 1]
    ])

    T = np.dot(T03, T34)
    T_CI = np.dot(T03, T34_CI)

    # Calcul des Jacobiennes
    xf = T_CI[:3, 3]

    position01 = T01[:3, 3]
    U01 = T01[:3, 2]
    Jc01 = np.cross(U01, (xf - position01))

    position02 = T02[:3, 3]
    U02 = T12[:3, 1]
    Jc02 = np.cross(U02, (xf - position02))

    position03 = T03[:3, 3]
    U03 = T23[:3, 1]
    Jc03 = np.cross(U03, (xf - position03))
    J_CI_1 = np.column_stack((Jc01, Jc02, Jc03))

    # 2√®me JCI
    xf = T03_CI[:3, 3]

    position01 = T01[:3, 3]
    U01 = T01[:3, 2]
    Jc01 = np.cross(U01, (xf - position01))

    position02 = T02[:3, 3]
    U02 = T12[:3, 1]
    Jc02 = np.cross(U02, (xf - position02))

    Jc03 = np.zeros(3)
    J_CI_2 = np.column_stack((Jc01, Jc02, Jc03))

    # 3√®me JCI
    xf = T02_CI[:3, 3]

    position01 = T01[:3, 3]
    U01 = T01[:3, 2]
    Jc01 = np.cross(U01, (xf - position01))

    Jc02 = np.zeros(3)
    Jc03 = np.zeros(3)
    J_CI_3 = np.column_stack((Jc01, Jc02, Jc03))

    # Calcul des moments
    J_tot = np.hstack((J_CI_1, J_CI_2, J_CI_3))
    Gamma_m = np.zeros((3, 3))

    Gamma_m[0, :] = np.dot(J_tot[:, :3].T, tau_i[:, 0])
    Gamma_m[1, :] = np.dot(J_tot[:, 3:6].T, tau_i[:, 1])
    Gamma_m[2, :] = np.dot(J_tot[:, 6:9].T, tau_i[:, 2])

    
    Qq = np.sum(Gamma_m, axis=0)  # Combien co√ªte chaque articulation en couple
    print(Gamma_m)
    print(Qq)

    return Qq

Q = equilibrageStatique(np.pi/2,0,float(0.5),0.3,0.2)
    

        </code></pre>
      </details>

        <hr>
        <h3>
        Mod√©lisation en lien avec le Hardware :
        </h3>

        <b>Dimensionnement </b><br>

        <p>
            Dans un premier temps, il fallait il s'agissait de dimensionner les deux liens
            du robot en fonction des capacit√©s des servomoteurs. 
        </p>

        <img src="\Projet\detail_robot.png" alt="Dimensionnement">
            <div class="legend">
                    <p>Resultat du code Dimensionnement</p>
            </div> 

        <p>
          On veut calculer les couples moteurs et les positions optimales 
          pour un syst√®me √† deux bras articul√©s portant une charge d'1 kg. 
          Cela permet de d√©terminer les longueurs maximales des bras en 
          respectant les limites de couple des moteurs.
        </p>

        <p>
          Chaque bras est compos√© de trois types de pi√®ces : 
          le d√©but proche du moteur (rotor, visserie), 
          la barre centrale dont la masse est proportionnelle √† la longueur, 
          et la fin du bras (support, charge). 
          Ces pi√®ces sont utilis√©es pour calculer le centre de gravit√© et 
          la masse totale de chaque bras.</p>

        <p>
          Ensuite on positionne les pi√®ces selon les longueurs des barres, 
          calcule le centre de gravit√© global, et d√©termine le couple 
          maximal n√©cessaire pour chaque moteur. 
        </p>

        <p>
          Ensuite, il faut effectuer un balayage des longueurs possibles des bras. 
          On retient la longueur maximale du bras 2 respectant la contrainte de 
          couple, puis la longueur maximale du bras 1 en tenant compte du bras 2 
          d√©j√† dimensionn√©. On prend une certaine marge d'erreur pour plus de s√©curit√©
          aussi
        </p>

        
        <img src="\Projet\dimension.png" alt="Dimensionnement">
            <div class="legend">
                    <p>Resultat du code Dimensionnement</p>
            </div> 


            <details >    
        <summary > <b style="color: red;">Code dimensionnement longueur des liens sur Python</b>
            </summary >
        <pre><button class="copy-btn" onclick="copyCode()">Copier</button><code id="code-block">    
import math
import matplotlib.pyplot as plt
import numpy as np


def dimensionnement(L1,PiecesBras1Debut,PiecesBras1Barre,PiecesBras1Fin,L2,PiecesBras2Debut,PiecesBras2Barre,PiecesBras2Fin):

    ## Constantes physiques et g√©om√©triques
    g=9.81                          # gravit√© (m/s¬≤)
    MasseLineique1=0.297            # masse lin√©ique du bras 1 (kg/m)
    MasseLineique2=0.136            # masse lin√©ique du bras 2 (kg/m)
    a=0.032                         # distance moteur1 ‚Üí d√©but des barres (m)
    b=0.04025                       # distance fin des barres ‚Üí moteur2 (m)
    l=L1+a+b                        # distance totale entre moteurs (m)

## --------------------------
## LIEN N¬∞2
## --------------------------

    ## Construction de la liste des pi√®ces du lien 2
    pb2f=[]                         # pi√®ces en fin de lien
    pb2b=[]                         # barre centrale

    # Mise √† jour position des pi√®ces en bout de lien
    for pieces in PiecesBras2Fin:
        Pieces2F=list(pieces)
        Pieces2F[0]+=L2+0.028       # d√©calage selon longueur du lien
        pb2f.append(Pieces2F)

    # Ajout de la masse de la barre centrale
    for pieces in PiecesBras2Barre:
        Pieces2B=list(pieces)
        Pieces2B[0] += L2/2+0.28    # centre de la barre
        Pieces2B[2] += L2*MasseLineique2  # masse proportionnelle √† la longueur
        pb2b.append(Pieces2B)

    # Assemblage complet des pi√®ces du lien 2
    Pieces2=PiecesBras2Debut+pb2b+pb2f

    ## Calcul du couple max moteur 2
    C2max=0
    M2=0                            # masse totale lien 2
    G2=[0,0]                        # centre de gravit√© (x,y)
    Xg2,Yg2=0,0

    # Calcul du barycentre global
    if len(Pieces2)!=0:
        for i in range (len(Pieces2)):
            M2+=Pieces2[i][2]              # somme des masses
            G2[0]+=Pieces2[i][0]*Pieces2[i][2]  # moment en x
            G2[1]+=Pieces2[i][1]*Pieces2[i][2]  # moment en y
        G2 = [c / M2 for c in G2]           # division par la masse totale

    Xg2,Yg2=G2[0],G2[1]

    # Couple moteur = distance centre de gravit√© √ó masse √ó g
    C2max=math.sqrt(Xg2**2+Yg2**2)*M2*g


## --------------------------
## LIEN N¬∞1
## --------------------------

    ## Construction des pi√®ces du lien 1
    pb1f=[]
    pb1b=[]

    # Pi√®ces en bout du lien
    for pieces in PiecesBras1Fin:
        Pieces1F=list(pieces)
        Pieces1F[0]+=L1+0.032
        pb1f.append(Pieces1F)

    # Barre centrale
    for pieces in PiecesBras1Barre:
        Pieces1B=list(pieces)
        Pieces1B[0] += L1/2+0.32
        Pieces1B[2] += L1*MasseLineique1
        pb1b.append(Pieces1B)

    # Assemblage complet du lien 1
    Pieces1=PiecesBras1Debut+pb1b+pb1f

    ## Calcul du couple moteur 1
    C1max=0
    M1=0
    G1=[0,0]
    Xg1,Yg1=0,0

    # Centre de gravit√© et masse totale
    if len(Pieces1)!=0:
        for i in range (len(Pieces1)):
            M1+=Pieces1[i][2]
            G1[0]+=Pieces1[i][0]*Pieces1[i][2]
            G1[1]+=Pieces1[i][1]*Pieces1[i][2]
        G1 = [c / M1 for c in G1]

    Xg1,Yg1=G1[0],G1[1]

    # Couple moteur 1 :
    # - lien 1
    # - plus lien 2 situ√© plus loin
    C1max=math.sqrt(Xg1**2+Yg1**2)*M1*g+(math.sqrt(Xg2**2+Yg2**2)+l)*M2*g


## --------------------------
## CALCUL DES ANGLES MAX
## --------------------------

    ## Angle du moteur 1 (position la plus d√©favorable)
    theta1=-math.pi/2
    if Xg1!=0:
        theta1=math.atan(Yg1/Xg1)-math.pi/2

    ## Angle du moteur 2
    theta2=0
    if Xg2!=0:
        theta2=math.atan(Yg2/Xg2)-(theta1+math.pi/2)

    # R√©sultats retourn√©s par la fonction
    return [C1max,C2max],[theta1,theta2],[G1,G2],[M1,M2],[Pieces1,Pieces2]


# ============================
# D√âFINITION DES PI√àCES
# ============================

# lien 1 - D√©but
strucRotor1=[0.022,0,0.051]
vissage1=[0.029,0,0.02]
PiecesBras1Debut=[strucRotor1,vissage1]

# lien 1 - Barre
barre1=[0,0,0]
PiecesBras1Barre=[barre1]

# lien 1 - Fin
petitDyna=[0.03,0,0.082]
support=[0.0025,0,0.005]
PiecesBras1Fin=[petitDyna,support]

# lien 2 - D√©but
palonier2=[0,0,0.01]
strucRotor2=[0.02,0,0.02]
vissage2=[0.028,0,0.005]
PiecesBras2Debut=[palonier2,strucRotor2,vissage2]

# lien 2 - Barre
barre2=[0,0,0]
PiecesBras2Barre=[barre2]

# lien 2 - Fin
cubeCorde=[0.005,0,0.005]
masse=[0.005,0,1]   # charge finale : 1 kg
PiecesBras2Fin=[masse,cubeCorde]


# ============================
# BALAYAGE DES LONGUEURS
# ============================

L1=np.linspace(0,0.4,401)   # longueurs possibles lien 1
L2=np.linspace(0,0.4,401)   # longueurs possibles lien 2
C2=[]
C1=[]

# Recherche longueur max du lien 2
for l2 in L2:
    [C1max,C2max],puppetT,puppetG,puppetM,puppetP=dimensionnement(0,PiecesBras1Debut,PiecesBras1Barre,PiecesBras1Fin,l2,PiecesBras2Debut,PiecesBras2Barre,PiecesBras2Fin)
    C2.append(C2max)

    # Si couple valide, on sauvegarde la longueur
    if C2max<=3.0*0.9:
        L2def=l2

# Recherche longueur max du lien 1 avec lien 2 d√©j√† dimensionn√©
for l1 in L1:
    [C1max,C2max],puppetT,puppetG,puppetM,puppetP=dimensionnement(l1,PiecesBras1Debut,PiecesBras1Barre,PiecesBras1Fin,L2def,PiecesBras2Debut,PiecesBras2Barre,PiecesBras2Fin)
    C1.append(C1max)

    if C1max<=7.3*0.9:
        L1def=l1


# ============================
# AFFICHAGE DES R√âSULTATS
# ============================

plt.plot(L1, C1, marker='.', linestyle='-', color='b', label='Cmot1(L1,L2)')
plt.plot(L2, C2, marker='.', linestyle='-', color='r', label='Cmot2(L2)')

plt.axhline(y=7.3, color='b', linestyle='-', label='Cmax1 = 7.3Nm')
plt.axhline(y=3, color='r', linestyle='-', label='Cmax2 = 3Nm')
plt.axhline(y=7.3*0.9, color='b', linestyle='--', label='L1 retenu: '+str(L1def*100)+'cm')
plt.axhline(y=3*0.9, color='r', linestyle='--', label='L2 retenu: '+str(L2def*100)+'cm')

plt.xlabel('Longueur de la barre')
plt.ylabel('Couple √† d√©velopper')
plt.title('Couple √† d√©velopper pour une masse d\'1kg pour des bras de taille L1,L2')

plt.legend()
plt.grid(True)
plt.show()

print("L1 et L2 retenus "+str(L1def)+" "+str(L2def))


# Calcul final avec longueurs retenues
puppetC,theta,G,M,P=dimensionnement(L1def,PiecesBras1Debut,PiecesBras1Barre,PiecesBras1Fin,L2def,PiecesBras2Debut,PiecesBras2Barre,PiecesBras2Fin)

G = [[float(x) for x in row] for row in G]
M = [float(x) for x in M]
theta = [float(x) for x in theta]

print("G: "+str(G))       # centres de gravit√©
print("M: "+str(M))       # masses totales
print("theta: "+str(theta))   # angles moteurs


        </code></pre>
      </details>

      <p>
        
      </p>

        <b>Courbe Couple/Courant</b>

      <p>
        Ayant maintenant acc√®s √† la position du robot, au couple n√©c√©ssaire
        pour chacune des positions il fallait ensuite d√©terminer combien de courant
        envoyer pour obtenir les couples voulu dans chaque moteurs. 
      </p>

      <p>
        Pour cela on dispose des graphs de performance des deux moteur utilis√©s :
      </p>

      <img src="\Projet\graph_performance.png" alt="graph_performance">
            <div class="legend">
                    <p>Graphique de performance des deux moteurs utilis√©s</p>
            </div> 


        <p>
            Ainsi on peut approximer ces courbes par des √©quations du \( 2^{nd}\) degr√© :
        </p>

        <p>On a trois points sur la courbe : 

        \[
        p_1 = \begin{pmatrix} x_1 \\ y_1 \end{pmatrix}, \quad
        p_2 = \begin{pmatrix} x_2 \\ y_2 \end{pmatrix}, \quad
        p_3 = \begin{pmatrix} x_3 \\ y_3 \end{pmatrix}
        \]
        </p>

        <p>On cherche \(a, b, c\) tels que :
        \[
        \forall n \in \{1,2,3\}, \quad a x_n^2 + b x_n + c = y_n
        \]
        </p>

        <p>Il suffit enfin de r√©soudre le syst√®me lin√©aire :
        \[
        \begin{pmatrix}
        x_1^2 & x_1 & 1 \\
        x_2^2 & x_2 & 1 \\
        x_3^2 & x_3 & 1
        \end{pmatrix}
        \begin{pmatrix}
        a \\ b \\ c
        \end{pmatrix}
        =
        \begin{pmatrix}
        y_1 \\ y_2 \\ y_3
        \end{pmatrix}
        \]
        </p>

        <p>
            <br>
        </p>

        <img src="\Projet\couple_courant.png" alt="Couple_Courant">
            <div class="legend">
                    <p>Resultat du code approximation courbe Couple-Courant</p>
            </div> 


            <details >    
        <summary > <b style="color: red;">Approximation courbe Couple-Courant sur Python</b>
            </summary >
        <pre><button class="copy-btn" onclick="copyCode()">Copier</button><code id="code-block">    
import numpy as np
import matplotlib.pyplot as plt
def findEq(p1,p2,p3):
    # Matrice des coefficients
    X = np.array([
        [p1[0]**2, p1[0], 1],
        [p2[0]**2, p2[0], 1],
        [p3[0]**2, p3[0], 1]
    ])

    # Vecteur des ordonn√©es
    Y = np.array([p1[1], p2[1], p3[1]])

    # R√©solution du syst√®me
    coefficients = np.linalg.solve(X, Y)

    # R√©sultats
    a, b, c = coefficients
    print(f"a = {a}, b = {b}, c = {c}")
    return a,b,c


p1=[0.207,140]
p2=[0.134,70]
p3=[0.355,250]


a,b,c=findEq(p1,p2,p3)


# G√©n√©rer des valeurs pour x
x = np.linspace(0.1, 0.4, 500)  # Intervalle de x avec 500 points

# Calculer y pour chaque valeur de x
y = a * x**2 + b * x + c

# Tracer la courbe
plt.figure(figsize=(8, 6))
plt.plot(x, y)

# Ajouter des labels, une grille et une l√©gende
plt.title("Graphique de l'√©quation du moteur CC")
plt.xlabel("Couple Nm")
plt.ylabel("PWM")
plt.axhline(0, color="black", linewidth=0.8, linestyle="--")
plt.axvline(0, color="black", linewidth=0.8, linestyle="--")
plt.grid(color="gray", linestyle="--", linewidth=0.5)
plt.legend()

# Afficher le graphique
plt.show()

        </code></pre>
      </details>

        <hr>
        <h3>
            Hardware & Liaison
         </h3>

         <p>
            Gr√¢ce √† mon Universit√© j'ai pu avoir acc√®s √† des servomoteurs Dynamixel pour 
            ce projet. Ceux-ci sont extr√™mement performants avec un grands nombre de capteur 
            et donc sont tr√®s cher.
         </p>

         <p>
            Gr√¢ce au capteur de courant instantan√© dans chaque servos on peut sans aucun
            hardware en plus control√© l'intensit√© du courant envoy√©, permettant un controle 
            en couple pr√©cis.
         </p>

         <p>
            Les moteurs sont respectivement les mod√®les XM540 W270 et XM430 W210.
         </p>

         <p>
            Pour li√©s les moteurs aux liens on utilise les cadres/frames sp√©ciales Dynamixel.
         </p>

         <img src="\Projet\montage.png" alt="Montage">
            <div class="legend">
                    <p>Exemple de cadre Dynamixel</p>
            </div> 


         <p>
            Les liens quand √† eux sont simplement des poutres en alumunium <a href=https://www.makerbeam.com/> MakerBeam</a><br> 
         </p>

         <p>
          La carte utilis√© pour relier PC et moteurs est la <a href=https://www.generationrobots.com/fr/402014-carte-dextension-opencm-485.html> 
            Carte d'extension OpenCM 485</a>
         </p>


         <p>
          Ainsi en utilisant tout les codes pr√©cendents et en les communiquants aux
          moteurs on arrive √† ce resultat : 
         </p>

         <video controls>
          <source src="/Projet/a_vide.mp4" type="video/mp4">
          Votre navigateur ne supporte pas la lecture vid√©o.
        </video>
        <div class="legend">
                    <p>Robot √† vide</p>
            </div> 


        <video controls>
          <source src="/Projet/500g.mp4" type="video/mp4">
          Votre navigateur ne supporte pas la lecture vid√©o.
        </video>
        <div class="legend">
                    <p>Robot avec 500g en bout d'effecteur</p>
            </div> 



          <details >    
        <summary > <b style="color: red;">Code final √©quilibrage statique robot 2 axes (Dynamixel) sur Python</b>
            </summary >
        <pre><button class="copy-btn" onclick="copyCode()">Copier</button><code id="code-block">    
import os
import dynamixel_sdk as dxl  # Uses Dynamixel SDK library
import numpy as np
import time
import matplotlib.pyplot as plt
import equilibrageStatique as eq
# Control table address
ADDR_TORQUE_ENABLE      = 64
ADDR_GOAL_POSITION      = 116
ADDR_PRESENT_POSITION   = 132

ADDR_GOAL_CURRENT       = 102
ADDR_PRESENT_CURRENT    = 126
ADDR_OPERATING_MODE     = 11  

# Data Byte Length
LEN_GOAL_POSITION       = 4
LEN_PRESENT_POSITION    = 4
LEN_GOAL_CURRENT        = 2
LEN_PRESENT_CURRENT     = 2


# Protocol version
PROTOCOL_VERSION        = 2.0  # Dynamixel XM540 uses protocol version 2.0

# Default setting
DXL_ID                  = 1    # Dynamixel ID
DXL_ID2                 = 2    # le deuxieme
BAUDRATE                = 57600
DEVICENAME              = 'COM4'  # Change to your port name (e.g., COM3 for Windows)

CURRENT_CONTROL_MODE    = 0    # Mode courant
TORQUE_ENABLE           = 1     # Value for enabling the torque
TORQUE_DISABLE          = 0     # Value for disabling the torque
DXL_MINIMUM_POSITION    = 0     # Minimum position value
DXL_MAXIMUM_POSITION    = 4095  # Maximum position value
DXL_MINIMUM_CURRENT     = 0
DXL_MAXIMUM_CURRENT     = 2047
DXL_MINIMUM_CURRENT2    = 0
DXL_MAXIMUM_CURRENT2    = 1193
DXL_MOVING_STATUS_THRESHOLD = 20  # Threshold for position change detection

# Initialize PortHandler and PacketHandler
portHandler = dxl.PortHandler(DEVICENAME)
packetHandler = dxl.PacketHandler(PROTOCOL_VERSION)

# Open port
if not portHandler.openPort():
    print("Failed to open the port!")
    quit()

# Set port baudrate
if not portHandler.setBaudRate(BAUDRATE):
    print("Failed to set the baudrate!")
    quit()

# Set Operating Mode to Current Control
dxl_comm_result, dxl_error = packetHandler.write1ByteTxRx(portHandler, DXL_ID, ADDR_OPERATING_MODE, CURRENT_CONTROL_MODE)
if dxl_comm_result != dxl.COMM_SUCCESS:
    print(f"Failed to set Operating Mode: {packetHandler.getTxRxResult(dxl_comm_result)}")
elif dxl_error != 0:
    print(f"Error setting Operating Mode: {packetHandler.getRxPacketError(dxl_error)}")
else:
    print("Operating Mode set to Current Control")


dxl_comm_result, dxl_error = packetHandler.write1ByteTxRx(portHandler, DXL_ID2, ADDR_OPERATING_MODE, CURRENT_CONTROL_MODE)
if dxl_comm_result != dxl.COMM_SUCCESS:
    print(f"Failed to set Operating Mode 2: {packetHandler.getTxRxResult(dxl_comm_result)}")
elif dxl_error != 0:
    print(f"Error setting Operating Mode 2: {packetHandler.getRxPacketError(dxl_error)}")
else:
    print("Operating Mode set to Current Control 2")

# Enable Dynamixel Torque
dxl_comm_result, dxl_error = packetHandler.write1ByteTxRx(portHandler, DXL_ID, ADDR_TORQUE_ENABLE, TORQUE_ENABLE)
if dxl_comm_result != dxl.COMM_SUCCESS:
    print(f"Failed to enable torque: {packetHandler.getTxRxResult(dxl_comm_result)}")
    quit()
elif dxl_error != 0:
    print(f"Torque enable error: {packetHandler.getRxPacketError(dxl_error)}")
    quit()
else:
    print("Torque enabled.")

dxl_comm_result, dxl_error = packetHandler.write1ByteTxRx(portHandler, DXL_ID2, ADDR_TORQUE_ENABLE, TORQUE_ENABLE)
if dxl_comm_result != dxl.COMM_SUCCESS:
    print(f"Failed to enable torque 2: {packetHandler.getTxRxResult(dxl_comm_result)}")
    quit()
elif dxl_error != 0:
    print(f"Torque enable error 2: {packetHandler.getRxPacketError(dxl_error)}")
    quit()
else:
    print("Torque enabled 2.")



M=input("masse en bout de bras (Kg):") #on fait nos teset en 0.5kg



plt.ion()  # initialise le plot
fig, ax = plt.subplots()
ax.set_title("Current Control - Real-Time Plot")
ax.set_xlabel("Time (s)")
ax.set_ylabel("Current (mA)")
ax.grid(True)

# Variables for plotting
time_data = []
current_data = []
current_data2 = []

def read_position(ID_DYNA):
    position, dxl_comm_result, dxl_error = packetHandler.read4ByteTxRx(portHandler, ID_DYNA, ADDR_PRESENT_POSITION)
    if dxl_comm_result != dxl.COMM_SUCCESS:
        print(f"Failed to read position for Motor {ID_DYNA}: {packetHandler.getTxRxResult(dxl_comm_result)}")
        return None
    elif dxl_error != 0:
        print(f"Position read error for Motor {ID_DYNA}: {packetHandler.getRxPacketError(dxl_error)}")
        return None
    return position*(2 * np.pi / 4096)

def read_current(ID_DYNA):
    present_current, dxl_comm_result, dxl_error = packetHandler.read2ByteTxRx(portHandler, ID_DYNA, ADDR_PRESENT_CURRENT)
    if dxl_comm_result != dxl.COMM_SUCCESS:
        print(f"Failed to read current: {packetHandler.getTxRxResult(dxl_comm_result)}")
        return None
    elif dxl_error != 0:
        print(f"Error reading current: {packetHandler.getRxPacketError(dxl_error)}")
        return None

    # Convertir la lecture du courant en valeur sign√©e
    #if present_current > 1023:
     #  present_current -= 2048

    return present_current # a encadrer si bug toujours
start_time = time.time() 
try:
    while 1:

        present_position = read_position(DXL_ID)
        if present_position is None:
            break
        present_position2 = read_position(DXL_ID2)
        if present_position2 is None:
            break

        Q=eq.equilibrageStatique(np.pi-present_position,np.pi-present_position2,float(M),0.3,0.2)
        print("pos",np.pi-present_position,np.pi-present_position2)
        
        courant1=(0.03869*Q[1]**2+0.49821*Q[1]+0)*1000
        courant2=(0.10621*Q[2]**2+0.555*Q[2]+0)*1000
        print(Q)
        
        # Desired current (goal current)
        desired_current_ma = courant1  # Example current value in mA
        desired_current = int(desired_current_ma/2.69) #unit scale are in 2.69 mA per unit


        desired_current_ma2 = courant2  # Example current value in mA
        desired_current2 = int(desired_current_ma2/2.69) #unit scale are in 2.69 mA per unit
        
        
        present_current = read_current(DXL_ID)
        if present_current is None:
            break
        present_current2 = read_current(DXL_ID2)
        if present_current2 is None:
            break


        # Limiter la sortie dans la plage autoris√©e
        output = max(DXL_MINIMUM_CURRENT, min(DXL_MAXIMUM_CURRENT, desired_current))

        output2 = max(DXL_MINIMUM_CURRENT2, min(DXL_MAXIMUM_CURRENT2, desired_current2))

        # √âcrire le courant cible
        dxl_comm_result, dxl_error = packetHandler.write2ByteTxRx(portHandler, DXL_ID, ADDR_GOAL_CURRENT,output)
        if dxl_comm_result != dxl.COMM_SUCCESS:
            print(f"Failed to write current: {packetHandler.getTxRxResult(dxl_comm_result)}")
            break
        elif dxl_error != 0:
            print(f"Error writing current: {packetHandler.getRxPacketError(dxl_error)}")
            break

        dxl_comm_result, dxl_error = packetHandler.write2ByteTxRx(portHandler, DXL_ID2, ADDR_GOAL_CURRENT,output2)
        if dxl_comm_result != dxl.COMM_SUCCESS:
            print(f"Failed to write current 2: {packetHandler.getTxRxResult(dxl_comm_result)}")
            break
        elif dxl_error != 0:
            print(f"Error writing current 2: {packetHandler.getRxPacketError(dxl_error)}")
            break

        # Debug
        print(f"Time: {time.time() - start_time:.2f}s, Desired Current: {desired_current}, Present Current: {present_current}, Output: {output}")
        print(f"Time: {time.time() - start_time:.2f}s, Desired Current 2: {desired_current2}, Present Current 2: {present_current2}, Output 2: {output2}")

        # Mise √† jour des donn√©es pour le graphique
        time_data.append(time.time() - start_time)

        current_data.append(present_current)
        current_data2.append(present_current2)

        desired_data = [desired_current] * len(time_data)
        desired_data2 = [desired_current2] * len(time_data)

        # Mise √† jour du graphique
        ax.clear()
        ax.plot(time_data, current_data, label="Measured Current", color="b")
        ax.plot(time_data, desired_data, label="Desired Current", color="r", linestyle="--")

        ax.plot(time_data, current_data2, label="Measured Current 2", color="y")
        ax.plot(time_data, desired_data2, label="Desired Current2", color="g", linestyle="-")

        ax.legend(loc="upper right")
        plt.pause(0.01)

        
        # Petit d√©lai pour stabiliser la boucle
        time.sleep(0.01)

except KeyboardInterrupt: #cltr + c
    print("PID control interrupted by user.")


finally:
    # Disable Dynamixel Torque
    dxl_comm_result, dxl_error = packetHandler.write1ByteTxRx(portHandler, DXL_ID, ADDR_TORQUE_ENABLE, TORQUE_DISABLE)
    if dxl_comm_result != dxl.COMM_SUCCESS:
        print(f"Failed to disable torque: {packetHandler.getTxRxResult(dxl_comm_result)}")
    elif dxl_error != 0:
        print(f"Torque disable error: {packetHandler.getRxPacketError(dxl_error)}")
    else:
        print("Torque disabled.")

    dxl_comm_result, dxl_error = packetHandler.write1ByteTxRx(portHandler, DXL_ID2, ADDR_TORQUE_ENABLE, TORQUE_DISABLE)
    if dxl_comm_result != dxl.COMM_SUCCESS:
        print(f"Failed to disable torque 2: {packetHandler.getTxRxResult(dxl_comm_result)}")
    elif dxl_error != 0:
        print(f"Torque disable error 2: {packetHandler.getRxPacketError(dxl_error)}")
    else:
        print("Torque disabled 2.")

    # Close port
    portHandler.closePort()
# Keep the plot open after the loop
    plt.ioff()
    plt.show()

        </code></pre>
      </details>


         <hr>
         <h3>
            Lien utile :
        </h3>

        <p>
            <a href=https://emanual.robotis.com/docs/en/dxl/x/xm540-w270/> e-Manual XM540 W270 Dynamixel</a><br>
            <a href=https://emanual.robotis.com/docs/en/dxl/x/xm430-w210/> e-Manual XM430 W210 Dynamixel</a><br>
            <a href=https://www.makerbeam.com/> Site MakerBeam</a><br>
        </p>
        </main>
</div>

<footer>
    ¬© 2025 - Guillaume Dengreville
</footer>

</body>
</html>