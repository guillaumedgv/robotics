<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Hough</title>
  <link rel="stylesheet" href="../style.css">
</head>
<body>

  <!-- Navbar dynamique -->
  <div id="navbar"></div>

  <!-- --- MathJax for LaTeX equations --- -->
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>

  <script>
  // Load navbar dynamically from external file
  fetch("navbar_vision.html")
    .then(response => response.text())  // Read the content as text
    .then(data => {
      // Insert the navbar HTML into the page
      document.getElementById("navbar").innerHTML = data;

      // ----------------------------
      // Highlight the current page
      // ----------------------------
      const currentPath = window.location.pathname;  // e.g., "/index.html"
      const links = document.querySelectorAll("#navbar nav a"); // all nav links

      links.forEach(link => {
        const href = link.getAttribute("href");
        if (!href) return; // Skip links without href

        // Normalize paths (remove leading slash) to compare properly
        const normalizedHref = href.replace(/^\//, "");
        const normalizedPath = currentPath.replace(/^\//, "");

        if (normalizedPath.endsWith(normalizedHref)) {
          // ‚úÖ Mark link of current page as active
          link.classList.add("active");

          // If the link is in a submenu, also highlight its parent
          const parentLi = link.closest("ul")?.closest("li");
          if (parentLi) {
            const parentLink = parentLi.querySelector(":scope > a");
            if (parentLink) parentLink.classList.add("active-parent");
          }
        } else {
          // Remove active class from other links
          link.classList.remove("active");
        }
      });

      // ----------------------------
      // Night mode toggle button
      // ----------------------------
      const themeToggle = document.getElementById("themeToggle");

      // On page load, check if user previously enabled night mode
      if (localStorage.getItem("nightMode") === "true") {
        document.body.classList.add("night");
        if (themeToggle) themeToggle.textContent = "‚òÄÔ∏è Day Mode";
      }

      // Set up click listener for the button
      if (themeToggle) {
        themeToggle.addEventListener("click", () => {
          document.body.classList.toggle("night"); // Toggle night mode

          // Save current mode in localStorage to persist across pages
          const isNight = document.body.classList.contains("night");
          localStorage.setItem("nightMode", isNight);

          // Update button text based on current mode
          themeToggle.textContent = isNight ? "‚òÄÔ∏è Day Mode" : "üåô Night Mode";
        });
      }
    })
    .catch(error => console.error("Erreur chargement navbar :", error));
</script>


<div class="container">
    <!-- Contenu principal -->
    <aside class="sidebar">
      <h3>Vision par Ordinateur</h3>
      <ul>
        <li><a href="/Vision/Transformation_Morpho.html">Transformation Morphologique</a></li>
        <li><a href="/Vision/Pattern_Reconnaissance.html">Reconnaissance de motifs </a></li>
        <li><a href="/Vision/Derive.html">D√©riv√©</a></li>
        <li><a href="/Vision/Hough.html" class="active">Transform√© de Hough </a></li>
      </ul>
    </aside> 

    <main class="content">

        <h1>Transform√©e de Hough pour la d√©tection de lignes droites</h1>

    <p>
    La <b>transform√©e de Hough</b> est une m√©thode robuste permettant de d√©tecter des
    <b>lignes droites</b> dans une image, m√™me en pr√©sence de bruit ou de discontinuit√©s.
    Elle est g√©n√©ralement appliqu√©e apr√®s un <b>pr√©-traitement</b> de d√©tection de contours,
    par exemple √† l‚Äôaide de l‚Äôalgorithme de <b>Canny</b>.
    </p>

    <h3>Principe</h3>

    <p>
    Une droite dans le plan image peut √™tre exprim√©e en <b>coordonn√©es polaires</b> par :
    </p>

    <p>
    \[
    r = x \cos\theta + y \sin\theta
    \]
    </p>

    <p>
    o√π :
    </p>
    <ul>
    <li>\(r\) est la distance de la droite √† l‚Äôorigine,</li>
    <li>\(\theta\) est l‚Äôangle entre l‚Äôaxe \(x\) et la perpendiculaire √† la droite,</li>
    <li>\((x,y)\) sont les coordonn√©es d‚Äôun pixel appartenant √† un contour.</li>
    </ul>

    <p>
    Pour chaque pixel de contour \((x,y)\), on balaie toutes les valeurs de
    \(\theta \in [0,180^\circ]\) et on calcule la valeur correspondante de \(r\).
    Chaque point image engendre alors une <b>courbe sinuso√Ødale</b> dans l‚Äôespace
    des param√®tres \((r,\theta)\).
    </p>

    <h3>Espace d‚Äôaccumulation</h3>

    <p>
    On d√©finit une matrice 2D appel√©e <b>matrice d‚Äôaccumulation</b> \(M(r,\theta)\).
    Chaque cellule correspond √† une paire possible \((r,\theta)\).
    </p>

    <p>
    Pour chaque pixel de contour :
    </p>
    <ul>
    <li>on balaie les valeurs de \(\theta\),</li>
    <li>on calcule \(r = x\cos\theta + y\sin\theta\),</li>
    <li>on convertit \(r\) en indice dans la matrice,</li>
    <li>on incr√©mente la case correspondante : \(M(r_i,\theta_i) = M(r_i,\theta_i) + 1\).</li>
    </ul>

    <h3>Discr√©tisation de \(r\)</h3>

    <p>
    La valeur maximale de \(r\) est donn√©e par :
    </p>

    <p>
    \[
    r_{\max} = \sqrt{h^2 + w^2}
    \]
    </p>

    <p>
    o√π \(h\) et \(w\) sont la hauteur et la largeur de l‚Äôimage.
    Le nombre de valeurs possibles pour \(r\) est alors :
    </p>

    <p>
    \[
    n_r = 2 \left\lfloor \frac{r_{\max}}{\text{res}} \right\rfloor + 1
    \]
    </p>

    <p>
    avec <b>res</b> la r√©solution de discr√©tisation (plus elle est grande,
    plus l‚Äôapproximation des lignes est grossi√®re).
    L‚Äôindice de \(r\) dans la matrice est calcul√© par :
    </p>

    <p>
    \[
    r_{\text{indice}} = \left\lfloor \frac{r + r_{\max}}{\text{res}} \right\rfloor
    \]
    </p>

    <h3>D√©tection des lignes</h3>

    <p>
    Les <b>maxima locaux</b> de la matrice d‚Äôaccumulation \(M(r,\theta)\),
    au-dessus d‚Äôun certain seuil, correspondent aux lignes les plus probables
    pr√©sentes dans l‚Äôimage.
    </p>

    <p>
    Une fois les param√®tres \((r,\theta)\) d√©tect√©s, on peut retracer chaque ligne
    dans l‚Äôimage en utilisant l‚Äô√©quation :
    </p>

    <p>
    \[
    r = x \cos\theta + y \sin\theta
    \]
    </p>


<hr>

<h1>
    Exemple en Manuel : 
</h1>

<img src="/Vision/10_sin_hough_line.png">


<img src="/Vision/hough_line_accu.png">


<img src="/Vision/hough_line_vote.png">


<img src="/Vision/hough_line_manual.png">
        <div class="legend">
            <p>
                Resultats 
            </p>
        </div>

<details>    
        <summary> <b style="color: red;">Algorithme Manuel Transform√© de Hough lin√©aire en Python</b>
            </summary>
        <pre><button class="copy-btn" onclick="copyCode()">Copier</button><code id="code-block">
import math
import cv2 as cv
import numpy as np
import matplotlib.pyplot as plt

# Lecture de l'image
src = cv.imread('test.jpg', cv.IMREAD_COLOR)
if src is None:
    print("Erreur : Image non charg√©e. V√©rifie le chemin du fichier.")
    exit()

# D√©tection des bords avec Canny
edges = cv.Canny(src, 100, 300, None, 3)

coords = []
ys, xs = np.nonzero(edges) # les points non null de Canny


height, width = edges.shape
diag_len = int(np.hypot(width, height)) # hypot = distance euclidienne entre l'origine (0, 0) et le point (x, y)
#diag_len = distance diagonal image >> rmax 

resolution = 1

accumulator = np.zeros((2 * diag_len, 180), dtype=np.uint64) # on couvre -rmax , ramx

for i in range(0,np.count_nonzero(edges)): 
    for theta in range(0, 180): 

        r = int(xs[i]*np.cos(math.radians(theta)) + ys[i]*np.sin(math.radians(theta))) # angle doivent √™tre en rad 

        # on le passe en indice pour l'accumulator
        r_idx = int(np.floor((r + diag_len)/resolution))  # d√©caler pour que rho soit ‚â• 0 >> mettre en indice 
        accumulator[r_idx, theta] += 1

        if i<11 :
        
            coords.append((math.radians(theta), r)) # pour le scatter
        


# Transformer en tableau numpy pour scatter 
coords = np.array(coords)
plt.figure(figsize=(10, 6))
plt.scatter(coords[:, 0], coords[:, 1], s=1, c='black')
plt.xlabel("Œ∏ (degr√©s)")
plt.ylabel("œÅ (r)")
plt.title(" exemple 10 sinsoid Espace de Hough simul√©")
plt.grid(True)
plt.show()


plt.imshow(accumulator, cmap='hot', aspect='auto')
plt.title("Accumulateur de Hough")
plt.xlabel("Œ∏ (en degr√©s)")
plt.ylabel("œÅ (d√©cal√©)")
plt.colorbar(label="Votes")
plt.show()

flat = accumulator.flatten() # suite en une dimension
plt.hist(flat[flat > 0], bins=100) # bins >> divise plage donnee en 100 intervalles
plt.title("Distribution des votes dans l'accumulateur")
plt.xlabel("Votes")
plt.ylabel("Nombre de (œÅ, Œ∏)")
plt.grid(True)
plt.show()

            </code></pre>
      </details>


    <hr>

    <h1>
        Exemple avec HoughLines & HoughLinesP (detection segments) : 
    </h1>

    <img src="/Vision/hough_line_segment.png">

    <details>    
            <summary> <b style="color: red;">Algorithme Transform√© de Hough de base et probabiliste lin√©aire en Python</b>
                </summary>
            <pre><button class="copy-btn" onclick="copyCode()">Copier</button><code id="code-block">
import math
import cv2 as cv
import numpy as np
import matplotlib.pyplot as plt

# Lecture de l'image
src = cv.imread('test.jpg', cv.IMREAD_COLOR)
if src is None:
    print("Erreur : Image non charg√©e. V√©rifie le chemin du fichier.")
    exit()

# D√©tection des bords avec Canny
edges = cv.Canny(src, 100, 300, None, 3)

# Copie pour dessiner les lignes d√©tect√©es
lines_img = cv.cvtColor(edges.copy(), cv.COLOR_GRAY2BGR)  # Pour HoughLines
linesP_img = cv.cvtColor(edges.copy(), cv.COLOR_GRAY2BGR)  # Pour HoughLinesP

# Hough transform (version standard)
lines = cv.HoughLines(edges, 1, np.pi / 180, 175)

if lines is not None:
    for i in range(len(lines)):
        rho = lines[i][0][0]
        theta = lines[i][0][1]
        a = math.cos(theta)
        b = math.sin(theta)
        x0 = a * rho
        y0 = b * rho
        pt1 = (int(x0 + 1000 * (-b)), int(y0 + 1000 * (a)))
        pt2 = (int(x0 - 1000 * (-b)), int(y0 - 1000 * (a)))
        cv.line(lines_img, pt1, pt2, (0, 0, 255), 2, cv.LINE_AA)

# Hough transform (version probabiliste)
linesP = cv.HoughLinesP(edges, 1, np.pi / 180, 50, minLineLength=50, maxLineGap=10)

if linesP is not None:
    for i in range(len(linesP)):
        l = linesP[i][0]
        pt1 = (l[0], l[1])
        pt2 = (l[2], l[3])
        cv.line(linesP_img, pt1, pt2, (0, 255, 0), 2, cv.LINE_AA)

# Affichage des r√©sultats
plt.figure(figsize=(12, 6))
plt.subplot(1, 2, 1)
plt.title("HoughLines")
plt.imshow(cv.cvtColor(lines_img, cv.COLOR_BGR2RGB))
plt.axis('off')

plt.subplot(1, 2, 2)
plt.title("HoughLinesP")
plt.imshow(cv.cvtColor(linesP_img, cv.COLOR_BGR2RGB))
plt.axis('off')

plt.tight_layout()
plt.show()


                </code></pre>
        </details>

    <p>
        <br>
    </p>


    <hr>

    <h1>Transform√©e de Hough pour la d√©tection de cercles</h1>

    <p>
    La <b>transform√©e de Hough pour les cercles</b> est une extension de la transform√©e
    de Hough pour les lignes. Elle permet de d√©tecter des <b>cercles</b> dans une image,
    g√©n√©ralement apr√®s un pr√©-traitement de d√©tection de contours (par exemple avec
    <b>Canny</b>).
    </p>

    <h3>Principe g√©n√©ral</h3>

    <p>
    Contrairement aux lignes, la d√©tection de cercles n√©cessite une √©tape suppl√©mentaire :
    la recherche des <b>centres potentiels</b> et du <b>rayon</b>.
    L‚Äôespace des param√®tres devient donc tridimensionnel.
    </p>

    <p>
    L‚Äô√©quation d‚Äôun cercle est donn√©e par :
    </p>

    <p>
    \[
    (x - a)^2 + (y - b)^2 = r^2
    \]
    </p>

    <p>
    o√π :
    </p>
    <ul>
    <li>\((x,y)\) sont les coordonn√©es d‚Äôun pixel de contour,</li>
    <li>\((a,b)\) sont les coordonn√©es du centre du cercle,</li>
    <li>\(r\) est le rayon.</li>
    </ul>

    <h3>Vote pour les centres de cercles</h3>

    <p>
    Pour un pixel de contour \((x,y)\) et pour un rayon \(r\) donn√©,
    on peut exprimer les coordonn√©es possibles du centre \((a,b)\)
    en fonction de l‚Äôorientation \(\theta\) :
    </p>

    <p>
    \[
    a = x - r \cos\theta
    \qquad
    b = y - r \sin\theta
    \]
    </p>

    <p>
    En balayant les valeurs de \(\theta \in [0, 360^\circ]\) (ou \([0,180^\circ]\)
    selon la sym√©trie) et une plage de rayons possibles, chaque pixel de contour
    <b>vote</b> pour un ensemble de centres candidats.
    </p>

    <h3>Espace d‚Äôaccumulation</h3>

    <p>
    On d√©finit une <b>matrice d‚Äôaccumulation 3D</b> :
    </p>

    <p>
    \[
    M(a,b,r)
    \]
    </p>

    <p>
    Chaque cellule correspond √† un cercle potentiel caract√©ris√© par
    un centre \((a,b)\) et un rayon \(r\).
    √Ä chaque vote, la case correspondante est incr√©ment√©e :
    </p>

    <p>
    \[
    M(a_i,b_i,r_i) = M(a_i,b_i,r_i) + 1
    \]
    </p>

    <h3>S√©lection des cercles</h3>

    <p>
    Les <b>maxima locaux</b> de la matrice \(M(a,b,r)\), au-dessus d‚Äôun seuil donn√©,
    correspondent aux cercles les plus probables dans l‚Äôimage.
    Un ajustement de type <i>best fit</i> sur le rayon peut √™tre effectu√© afin
    d‚Äôam√©liorer la pr√©cision du cercle d√©tect√©.
    </p>

    <p>
    Une fois les param√®tres \((a,b,r)\) d√©termin√©s, le cercle peut √™tre retrac√©
    directement dans l‚Äôimage √† partir de son √©quation g√©om√©trique.
    </p>

    <hr>

    <h1>Exemple manuel :</h1>


    <img src="/Vision/hough_circle_manual.png">

    <details>    
            <summary> <b style="color: red;">Algorithme manuel Transform√© de Hough circulaire en Python</b>
                </summary>
            <pre><button class="copy-btn" onclick="copyCode()">Copier</button><code id="code-block">
import math
import cv2 as cv
import numpy as np
import matplotlib.pyplot as plt


src = cv.imread('ball.jpg', cv.IMREAD_COLOR)
if src is None:
    print("Erreur : Image non charg√©e. V√©rifie le chemin du fichier.")
    exit()

src_manu = src.copy()

gray = cv.cvtColor(src, cv.COLOR_BGR2GRAY)

blur = cv.GaussianBlur(gray, (9, 9), 2)
canny = cv.Canny(blur, 200, 100)


plt.figure(figsize=(12, 6))
plt.imshow(cv.cvtColor(canny, cv.IMREAD_GRAYSCALE))
plt.axis('off')

# initialise l'accumulateur
rows, cols = canny.shape
minR, maxR = 50, 100
acc = np.zeros((rows, cols, maxR - minR), dtype=np.uint64) #trois parametre x , y et rayon

ys, xs = np.nonzero(canny)

for x, y in zip(xs, ys):
    for r in range(minR, maxR):
        for theta in range(0, 360, 5):  # plus rapide que chaque degr√©
            a = int(x - r * np.cos(np.radians(theta)))
            b = int(y - r * np.sin(np.radians(theta)))

            if 0 <= a < cols and 0 <= b < rows:
                acc[b, a, r - minR] += 1

max_vote = np.max(acc) 

threshold = 0.95 * max_vote

centers = np.where(acc > threshold)

for b, a, r in zip(*centers):
    cv.circle(src_manu, (a, b), r + minR, (0, 255, 0), 2)

plt.imshow(cv.cvtColor(src_manu, cv.COLOR_BGR2RGB))
plt.axis('off')
plt.title("cercle d√©tect√©es")
plt.show()
                </code></pre>
        </details>

        <hr>

    <h1>Exemple avec HoughCircles() :</h1>


    <img src="/Vision/hough_circle.png">

    <details>    
            <summary> <b style="color: red;">Algorithme Transform√© de Hough circulaire en Python</b>
                </summary>
            <pre><button class="copy-btn" onclick="copyCode()">Copier</button><code id="code-block">
import math
import cv2 as cv
import numpy as np
import matplotlib.pyplot as plt


src = cv.imread('ball.jpg', cv.IMREAD_COLOR)
if src is None:
    print("Erreur : Image non charg√©e. V√©rifie le chemin du fichier.")
    exit()

src_manu = src.copy()

gray = cv.cvtColor(src, cv.COLOR_BGR2GRAY)

src_blur = cv.GaussianBlur(gray, (9, 9),2) #le 2 est le sigmaX -> + grand + blur -> 2 commun pour d√©bruiter

rows = src_blur.shape[0]
circles = cv.HoughCircles(src_blur, cv.HOUGH_GRADIENT, 1, rows / 8,    # dp = 1 --> resolution de l'accumulateur, minDist = rows / 8 distance mini deux centre
                               param1=100, param2=50, #  param1 = seuil sup > seuil inf = param1/2, param2 = seuil accu + bas  + de d√©tections, mais aussi + de faux positifs
                               minRadius=1, maxRadius=100)
    
    
if circles is not None:
    circles = np.uint16(np.around(circles)) # around arrondis les valeurs
    for i in circles[0, :]: # circle retourn x,y,r
        center = (i[0], i[1])
        # circle center
        cv.circle(src, center, 1, (0, 100, 100), 3)
        # circle outline
        radius = i[2]
        cv.circle(src, center, radius, (255, 0, 255), 3)


plt.figure(figsize=(12, 6))
plt.title("HoughCircle")
plt.imshow(cv.cvtColor(src, cv.COLOR_BGR2RGB))
plt.axis('off')

                </code></pre>
        </details>



    </main>
</div>

<footer>
    ¬© 2025 - Guillaume Dengreville
</footer>

</body>

</html>
