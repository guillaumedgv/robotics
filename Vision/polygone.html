<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Distance aux contours & Moments</title>
  <link rel="stylesheet" href="../style.css">
</head>
<body>

  <!-- Navbar dynamique -->
  <div id="navbar"></div>

  <!-- --- MathJax for LaTeX equations --- -->
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>

  <script>
  // Load navbar dynamically from external file
  fetch("navbar_vision.html")
    .then(response => response.text())  // Read the content as text
    .then(data => {
      // Insert the navbar HTML into the page
      document.getElementById("navbar").innerHTML = data;

      // ----------------------------
      // Highlight the current page
      // ----------------------------
      const currentPath = window.location.pathname;  // e.g., "/index.html"
      const links = document.querySelectorAll("#navbar nav a"); // all nav links

      links.forEach(link => {
        const href = link.getAttribute("href");
        if (!href) return; // Skip links without href

        // Normalize paths (remove leading slash) to compare properly
        const normalizedHref = href.replace(/^\//, "");
        const normalizedPath = currentPath.replace(/^\//, "");

        if (normalizedPath.endsWith(normalizedHref)) {
          // ‚úÖ Mark link of current page as active
          link.classList.add("active");

          // If the link is in a submenu, also highlight its parent
          const parentLi = link.closest("ul")?.closest("li");
          if (parentLi) {
            const parentLink = parentLi.querySelector(":scope > a");
            if (parentLink) parentLink.classList.add("active-parent");
          }
        } else {
          // Remove active class from other links
          link.classList.remove("active");
        }
      });

      // ----------------------------
      // Night mode toggle button
      // ----------------------------
      const themeToggle = document.getElementById("themeToggle");

      // On page load, check if user previously enabled night mode
      if (localStorage.getItem("nightMode") === "true") {
        document.body.classList.add("night");
        if (themeToggle) themeToggle.textContent = "‚òÄÔ∏è Day Mode";
      }

      // Set up click listener for the button
      if (themeToggle) {
        themeToggle.addEventListener("click", () => {
          document.body.classList.toggle("night"); // Toggle night mode

          // Save current mode in localStorage to persist across pages
          const isNight = document.body.classList.contains("night");
          localStorage.setItem("nightMode", isNight);

          // Update button text based on current mode
          themeToggle.textContent = isNight ? "‚òÄÔ∏è Day Mode" : "üåô Night Mode";
        });
      }
    })
    .catch(error => console.error("Erreur chargement navbar :", error));
</script>


<div class="container">
    <!-- Contenu principal -->
    <aside class="sidebar">
      <h3>Vision par Ordinateur</h3>
      <ul>
        <ul>
        <li><a href="Transformation_Morpho.html">Transformation Morphologique</a></li>
        <li><a href="Pattern_Reconnaissance.html">Reconnaissance de motifs </a></li>
        <li><a href="Derive.html">D√©riv√©</a></li>
        <li><a href="Hough.html">Transform√© de Hough </a></li>
        <li><a href="Extract_line.html">Extraction de lignes</a></li>
        <li><a href="Convex_hull.html">Enveloppe convexe</a></li>
        <li><a href="polygone.html">Distance aux contours & Moments</a></li>
        <li><a href="remappinge.html">Remapping</a></li>
        <li><a href="affine_dft.html" >Transformation affine & DFT</a></li>
        <li><a href="Watershed.html" class="active">Algorithme Watershed</a></li>

      </ul>
      </ul>
    </aside> 

    <main class="content">

        <h1>Distance √† un contours</h1>

        <p>
            Dans un premier temps on cree un polygone quelconque que l'on dessine dans une image (peut d√©ja utile pour cr√©er des ROI ou hitbox) : 
        </p>


        <img src="poly_random.png">
        <div class="legend">
            <p>
                Polygone quelconque
            </p>
        </div>


        <p>
            Esnuite on utilise <em>pointPolygonTest</em> pour connaitre, soit la distance entre chaque pixel et un contour 
            du polygone, soit si l'on est dans le polygone
        </p>

        <p>
            De l√† gr√¢ce √† <em>minMaxLoc</em> on peut d√©duire les minimums et maximums locaux et enfin les 
            interpreter comme des gradient et utiliser ces information pour d'autres calculs.
        </p>

         <img src="poly.png">
        <div class="legend">
            <p>
                Gradient de distanhce au polygone (avec plus grand cercle inscrit calcul√© √† partir de <em>minMaxLoc</em>)
            </p>
        </div>

        <details>    
        <summary> <b style="color: red;">Algorithme calcul de distance √† un contour en Python</b>
            </summary>
        <pre><button class="copy-btn" onclick="copyCode()">Copier</button><code id="code-block">
import cv2 as cv
import numpy as np
import argparse
import random as rng
import matplotlib.pyplot as plt


# Create an image
r = 100
src = np.zeros((4*r, 4*r), dtype=np.uint8)

drawing = np.zeros((src.shape[0], src.shape[1], 3), dtype=np.uint8) # pour l'imager

# Create a sequence of points to make a contour
vert = [None]*6
vert[0] = (3*r//2, int(1.34*r))
vert[1] = (1*r, 2*r)
vert[2] = (2*r//2, int(2.866*r))
vert[3] = (4*r//2, int(2.866*r))
vert[4] = (3*r, 2*r)
vert[5] = (3*r//2, int(1.34*r))
# Draw it in src
for i in range(6):
    cv.line(src, vert[i],  vert[(i+1)%6], ( 255 ), 3) 
# trace une ligne entre  i et i+1 >> le modulo est une astuce pour ferm√© la forme pour avoir i √† 0

    # Get the contours
contours, _ = cv.findContours(src, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE) 
# EXTERNAL car sinon contours donne deux contours ext et interieur avec cv.line

raw_dist = np.empty(src.shape, dtype=np.float32)

# Calculate the distances to the contour
for i in range(src.shape[0]):
    for j in range(src.shape[1]):
        raw_dist[i,j] = cv.pointPolygonTest(contours[0], (j,i), True) 
# contour 0 est la forme dessin√©, 
# retourne une matrice de la mm taille que src de la distance au contour 
#(True √† la fin) ou si on est dedans (False √† la fin)
# distance positive √† l'interieur, negative √† l'exterieur et 0 sur le contour

minVal, maxVal, minDistPt, maxDistPt = cv.minMaxLoc(raw_dist) 
minVal = abs(minVal)
maxVal = abs(maxVal)
#minVal ‚Üí distance n√©gative la plus √©loign√©e (ext√©rieur)
#maxVal ‚Üí distance positive la plus √©loign√©e (centre)
#maxDistPt ‚Üí point le plus loin du contour √† l‚Äôint√©rieur
#minDistPt ‚Üí point le plus loin du contour √† l‚Äôexterieur


for i in range(src.shape[0]): # pour les gradient 
    for j in range(src.shape[1]):
        if raw_dist[i,j] < 0:
            drawing[i,j,0] = 255 - abs(raw_dist[i,j]) * 255 / minVal
        elif raw_dist[i,j] > 0:
            drawing[i,j,2] = 255 - raw_dist[i,j] * 255 / maxVal
        else:
            drawing[i,j,0] = 255
            drawing[i,j,1] = 255
            drawing[i,j,2] = 255

cv.circle(drawing,maxDistPt, int(maxVal),(255,255,255), 1, cv.LINE_8, 0)
plt.imshow(src)
plt.show()

plt.imshow(drawing)
plt.show()
       </code></pre>
    </details>


    <hr>
    <h1>Moment d'une forme</h1>

    <p>
    En traitement d‚Äôimages, les <strong>moments g√©om√©triques</strong> d√©crivent la r√©partition spatiale
    des intensit√©s d‚Äôune image <span>\(I(x,y)\)</span>.  
    </p>
    <p>
    Le moment d‚Äôordre z√©ro 
    <span>\(m_{00} = \sum_x \sum_y I(x,y)\)</span> correspond √† l‚Äôaire (ou √† la masse totale)
    de l‚Äôobjet pour une image binaire, ou √† la somme des intensit√©s pour une image en niveaux de gris.
      </p>
    <p>
    Les moments du premier ordre : <br>
    <span>\(m_{10} = \sum_x \sum_y x\,I(x,y)\)</span> et 
    <span>\(m_{01} = \sum_x \sum_y y\,I(x,y)\)</span> d√©crivent respectivement la distribution
    horizontale et verticale de la masse ; ils sont utilis√©s pour calculer le centre de gravit√©
    de la forme.
    </p>

    <p>
    Les moments du second ordre apportent des informations sur la <strong>dispersion</strong>
    et l‚Äô<strong>orientation</strong> de l‚Äôobjet.  <br>
    Le moment crois√© 
    <span>\(m_{11} = \sum_x \sum_y x\,y\,I(x,y)\)</span> mesure la corr√©lation entre les axes
    <span>\(x\)</span> et <span>\(y\)</span> et renseigne sur l‚Äôobliquit√© ou l‚Äôorientation diagonale de la forme.
    Les moments 
    <span>\(m_{20} = \sum_x \sum_y x^2\,I(x,y)\)</span> et 
    <span>\(m_{02} = \sum_x \sum_y y^2\,I(x,y)\)</span> repr√©sentent quant √† eux les variances
    horizontale et verticale : ils indiquent √† quel point la forme est √©tal√©e
    le long des axes <span>\(X\)</span> et <span>\(Y\)</span>.  
    </p>
    <p>
    Ensemble, ces moments constituent une description compacte de la taille,
    de la position et de l‚Äôorientation d‚Äôun objet dans l‚Äôimage.
    </p>

    <h3>Calcul du centro√Øde (centre de masse)</h3> 

    <p>
    Le <strong>centro√Øde</strong> d‚Äôun objet correspond √† son <em>centre de masse g√©om√©trique</em>.
    Il est calcul√© √† partir des moments g√©om√©triques du premier ordre.
    </p>

    <p>
    Le centro√Øde <span>\((x_c, y_c)\)</span> est alors donn√© par :
    </p>

    <p>
    \[
    x_c = \frac{m_{10}}{m_{00}},
    \qquad
    y_c = \frac{m_{01}}{m_{00}}
    \]
    </p>

    <p>
    Intuitivement, <span>\(m_{10}\)</span> et <span>\(m_{01}\)</span> mesurent la r√©partition
    de la masse selon les axes horizontal et vertical, tandis que <span>\(m_{00}\)</span>
    repr√©sente la masse totale. Le centro√Øde correspond donc au point d‚Äô√©quilibre de la forme.
    </p>

    <h3>Calcul de l‚Äôorientation de la forme</h3> 

    <p>
    L‚Äô<strong>orientation</strong> d‚Äôun objet est d√©finie comme l‚Äôangle entre l‚Äôaxe horizontal
    et l‚Äôaxe principal de la forme, c‚Äôest-√†-dire la direction selon laquelle l‚Äôobjet est
    le plus √©tendu. Cette orientation est calcul√©e √† partir des
    <strong>moments centraux d‚Äôordre 2</strong>.
    </p>

   
    <p>
    En particulier :
    </p>

    <p>
    \[
    m_{20}, \quad m_{02} \quad \text{(variances horizontale et verticale)}
    \]
    \[
    m_{11} \quad \text{(corr√©lation entre } x \text{ et } y\text{)}
    \]
    </p>

    <p>
    L‚Äôangle d‚Äôorientation <span>\(\theta\)</span> de la forme est alors donn√© par :
    </p>

    <p>
    \[
    \theta = \frac{1}{2}
    \arctan\!\left(
    \frac{2\,m_{11}}{m_{20} - m_{02}}
    \right)
    \]
    </p>

    <p>
    Cette formule provient de l‚Äôanalyse des axes principaux d‚Äôinertie de la forme.
    Le terme <span>\(m_{11}\)</span> traduit l‚Äôinclinaison diagonale, tandis que
    la diff√©rence <span>\(m_{20} - m_{02}\)</span> compare les dispersions horizontale
    et verticale. Le facteur <span>\(\frac{1}{2}\)</span> est d√ª √† la sym√©trie de l‚Äôellipse
    √©quivalente √† la forme.
    </p>

    <p>
    L‚Äôangle <span>\(\theta\)</span> est exprim√© en radians et peut √™tre converti en degr√©s par :
    </p>

    <p>
    \[
    \theta_{\text{deg}} = \theta \times \frac{180}{\pi}
    \]
    </p>

    <p>
    Ainsi, l‚Äôorientation correspond √† la rotation n√©cessaire pour aligner la forme
    sur son axe principal, ce qui est particuli√®rement utile pour l‚Äôanalyse de formes
    et la vision par ordinateur.
    </p>


      <img src="moment.png">
        <div class="legend">
            <p>
                Centre de masse du polygone
            </p>
        </div>

        <p>
            Ici on trouve une orientation de ce polygone de -14¬∞
        </p>

        <details>    
        <summary> <b style="color: red;">Algorithme calcul centroide et orientation en Python</b>
            </summary>
        <pre><button class="copy-btn" onclick="copyCode()">Copier</button><code id="code-block">
import cv2 as cv
import numpy as np
import argparse
import random as rng
import matplotlib.pyplot as plt
import math

# Create an image
r = 100
src = np.zeros((4*r, 4*r), dtype=np.uint8)

drawing = np.zeros((src.shape[0], src.shape[1], 3), dtype=np.uint8) # pour l'imager

# Create a sequence of points to make a contour
vert = [None]*6
vert[0] = (3*r//2, int(1.34*r))
vert[1] = (1*r, 2*r)
vert[2] = (2*r//2, int(2.866*r))
vert[3] = (4*r//2, int(2.866*r))
vert[4] = (3*r, 2*r)
vert[5] = (3*r//2, int(1.34*r))
# Draw it in src
for i in range(6):
    cv.line(src, vert[i],  vert[(i+1)%6], ( 255 ), 3) 
# trace une ligne entre  i et i+1 >> le modulo est une astuce pour ferm√© la forme pour avoir i √† 0

    # Get the contours
contours, _ = cv.findContours(src, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE) #
 EXTERNAL car sinon contours donne deux contours ext et interieur avec cv.line


# Calcul des moments 
mu = [None]*len(contours)

for i in range(len(contours)):
    # m00  : moment d‚Äôordre 0  ‚Üí aire
    # m10, m01 : moments d‚Äôordre 1 ‚Üí centre de masse
    # m20, m11, m02 : moments d‚Äôordre 2 ‚Üí dispersion et orientation
    mu[i] = cv.moments(contours[i]) 


# Calcul des centres de masse

mc = [None]*len(contours)

for i in range(len(contours)):
    # Calcul du centro√Øde (centre de masse)
    # x_c = m10 / m00
    # y_c = m01 / m00
    # Le terme 1e-5 √©vite une division par z√©ro si l‚Äôaire est nulle
    mc[i] = (mu[i]['m10'] / (mu[i]['m00'] + 1e-5),
             mu[i]['m01'] / (mu[i]['m00'] + 1e-5))
    
    # Dessine le centre de masse sur l‚Äôimage (point violet)
    cv.circle(drawing,
              (int(mc[i][0]), int(mc[i][1])),
              4,
              [255, 0, 255],
              -1)


# Comparaison des aires et calcul du p√©rim√®tre
for i in range(len(contours)):
    print(
        ' * Contour[%d] - Area (M_00) = %.2f - Area OpenCV: %.2f - Length: %.2f'
        % (
            i,
            mu[i]['m00'],                       # Aire via le moment m00
            cv.contourArea(contours[i]),        # Aire via OpenCV
            cv.arcLength(contours[i], True)     # P√©rim√®tre du contour (True = ferm√©)
        )
    )


# Calcul de l‚Äôorientation principale de la forme

# Calcul de l‚Äôangle de l‚Äôaxe principal de la forme
# L‚Äôangle correspond √† la direction selon laquelle la forme est la plus √©tendue
# Formule issue des moments centraux d‚Äôordre 2
angle = 0.5 * math.atan2(
    2 * mu[0]['mu11'],                 # Corr√©lation X-Y
    mu[0]['mu20'] - mu[0]['mu02']      # Diff√©rence des dispersions horizontale/verticale
)

# Conversion de l‚Äôangle de radians vers degr√©s
angle_degrees = math.degrees(angle)

# Affichage de l‚Äôorientation de la forme
print('Orientation = %d degr√©s' % angle_degrees)


plt.imshow(drawing)
plt.axis('off')
plt.show()


        </code></pre>
    </details>


    </main>
</div>

<footer>
    ¬© 2025 - Guillaume Dengreville
</footer>

</body>

</html>
