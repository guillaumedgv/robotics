<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Derive</title>
  <link rel="stylesheet" href="../style.css">
</head>
<body>

  <!-- Navbar dynamique -->
  <div id="navbar"></div>

  <!-- --- MathJax for LaTeX equations --- -->
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>

  <script>
  // Load navbar dynamically from external file
  fetch("navbar_vision.html")
    .then(response => response.text())  // Read the content as text
    .then(data => {
      // Insert the navbar HTML into the page
      document.getElementById("navbar").innerHTML = data;

      // ----------------------------
      // Highlight the current page
      // ----------------------------
      const currentPath = window.location.pathname;  // e.g., "/index.html"
      const links = document.querySelectorAll("#navbar nav a"); // all nav links

      links.forEach(link => {
        const href = link.getAttribute("href");
        if (!href) return; // Skip links without href

        // Normalize paths (remove leading slash) to compare properly
        const normalizedHref = href.replace(/^\//, "");
        const normalizedPath = currentPath.replace(/^\//, "");

        if (normalizedPath.endsWith(normalizedHref)) {
          // ‚úÖ Mark link of current page as active
          link.classList.add("active");

          // If the link is in a submenu, also highlight its parent
          const parentLi = link.closest("ul")?.closest("li");
          if (parentLi) {
            const parentLink = parentLi.querySelector(":scope > a");
            if (parentLink) parentLink.classList.add("active-parent");
          }
        } else {
          // Remove active class from other links
          link.classList.remove("active");
        }
      });

      // ----------------------------
      // Night mode toggle button
      // ----------------------------
      const themeToggle = document.getElementById("themeToggle");

      // On page load, check if user previously enabled night mode
      if (localStorage.getItem("nightMode") === "true") {
        document.body.classList.add("night");
        if (themeToggle) themeToggle.textContent = "‚òÄÔ∏è Day Mode";
      }

      // Set up click listener for the button
      if (themeToggle) {
        themeToggle.addEventListener("click", () => {
          document.body.classList.toggle("night"); // Toggle night mode

          // Save current mode in localStorage to persist across pages
          const isNight = document.body.classList.contains("night");
          localStorage.setItem("nightMode", isNight);

          // Update button text based on current mode
          themeToggle.textContent = isNight ? "‚òÄÔ∏è Day Mode" : "üåô Night Mode";
        });
      }
    })
    .catch(error => console.error("Erreur chargement navbar :", error));
</script>


<div class="container">
    <!-- Contenu principal -->
    <aside class="sidebar">
      <h3>Vision par Ordinateur</h3>
      <ul>
        <ul>
        <li><a href="Transformation_Morpho.html">Transformation Morphologique</a></li>
        <li><a href="Pattern_Reconnaissance.html">Reconnaissance de motifs </a></li>
        <li><a href="Derive.html" class="active">D√©riv√©</a></li>
        <li><a href="Contours.html">Extraction des contours</a></li>
        <li><a href="Hough.html">Transform√© de Hough </a></li>
        <li><a href="Extract_line.html">Extraction de lignes</a></li>
        <li><a href="Convex_hull.html">Enveloppe convexe</a></li>
        <li><a href="polygone.html">Distance aux contours & Moments</a></li>
        <li><a href="remapping.html">Remapping</a></li>
        <li><a href="affine_dft.html" >Transformation affine & DFT</a></li>
        <li><a href="Watershed.html">Algorithme Watershed</a></li>

      </ul>
      </ul>
    </aside> 

    <main class="content">

  <h1>D√©riv√©es d'image : Sobel et Scharr</h1>

  <p>
    Pour d√©tecter les bords d'une image, on calcule les d√©riv√©es horizontales et verticales de l'image.  
    Deux fonctions classiques sont disponibles :
  </p>
  <ul>
    <li><b>Sobel()</b> : calcule les d√©riv√©es avec un kernel simple.</li>
    <li><b>Scharr()</b> : calcule des d√©riv√©es plus pr√©cises avec un kernel de taille 3x3.</li>
  </ul>

  <h3>Principe g√©n√©ral</h3>
  <p>
    On effectue une <b>convolution</b> d'un kernel \(K\) (de taille impaire \(n \times n\)) avec l'image \(I\) :
  \[
  G = K * I
  \]
  </p>
  <p>
    La convolution consiste √† glisser un petit tableau de poids (le kernel) sur l‚Äôimage, et pour chaque pixel, on fait une somme pond√©r√©e des pixels voisins :
 

  \[
  G_{x} = K_x * I \quad\text{(horizontal)}, \quad 
  G_{y} = K_y * I \quad\text{(vertical)}
  \]
     </p>
  <p>
    Puis, pour chaque pixel, on calcule la norme du gradient :
  
  \[
  G = \sqrt{G_x^2 + G_y^2}
  \]

  </p>

  <h3>Kernels classiques</h3>

  <p><b>Sobel 3x3 :</b>
  \[
  K_x =
  \begin{bmatrix}
  -1 & 0 & 1\\
  -2 & 0 & 2\\
  -1 & 0 & 1
  \end{bmatrix}, \quad
  K_y =
  \begin{bmatrix}
  -1 & -2 & -1\\
  0 & 0 & 0\\
  1 & 2 & 1
  \end{bmatrix}
  \]
 </p>
  <p><b>Scharr 3x3 :</b>
  \[
  K_x =
  \begin{bmatrix}
  -3 & 0 & 3\\
  -10 & 0 & 10\\
  -3 & 0 & 3
  \end{bmatrix}, \quad
  K_y =
  \begin{bmatrix}
  -3 & -10 & -3\\
  0 & 0 & 0\\
  3 & 10 & 3
  \end{bmatrix}
  \]
 </p>
 

  <h3>Exemple de calcul de bord</h3>

  <p>
  Si deux pixels voisins ont des intensit√©s tr√®s diff√©rentes, par exemple \(I_1 = 255\) et \(I_2 = 10\), alors la diff√©rence absolue :
  
  \[
  |I_1 - I_2| = 245
  \]
  indique la pr√©sence d'un bord.
  </p>

  <p>
  La matrice \([-1\ 0\ 1]\) est la matrice de d√©rivation de base ; on augmente sa taille ou on utilise un kernel plus large pour r√©duire le bruit en faisant une moyenne pond√©r√©e des pixels voisins.
  </p>

  <h3>Exemple de d√©riv√©</h3>

  <img src="scharr.png">
        <div class="legend">
            <p>
                D√©riv√© avec Scharr
            </p>
        </div>

       <details>    
        <summary> <b style="color: red;">Partie op√©rateur Sobel & Scharr Python</b>
            </summary>
        <pre><button class="copy-btn" onclick="copyCode()">Copier</button><code id="code-block">
import cv2 as cv
import matplotlib.pyplot as plt
import numpy as np

scale = 1 #facteur multiplicatif appliqu√© au gradient calcul√©.
delta = 0 #valeur ajout√©e au r√©sultat final.
ddepth = cv.CV_16S # profoneur de l'image, ici signed 16-bit >> On utilise une profondeur plus grande pour √©viter la perte d'information lors des calculs de gradient.

src = cv.imread('stare.jpg', cv.IMREAD_COLOR) # load l'image

src = cv.GaussianBlur(src, (3, 3), 0) # pour r√©duire le bruit et √©viter les erreurs lors de la d√©tection de bords --> 0 = √©cart-type (sigma) en X et Y

gray = cv.cvtColor(src, cv.COLOR_BGR2GRAY) # on met en teinte de gris


#grad_x = cv.Sobel(gray, ddepth, 1, 0, ksize=3, scale=scale, delta=delta, borderType=cv.BORDER_DEFAULT)
#grad_y = cv.Sobel(gray, ddepth, 0, 1, ksize=3, scale=scale, delta=delta, borderType=cv.BORDER_DEFAULT) 

grad_x = cv.Scharr(gray,ddepth,1,0) #This is as fast but more accurate than the standard Sobel function.
grad_y = cv.Scharr(gray,ddepth,0,1)
    
abs_grad_x = cv.convertScaleAbs(grad_x) #convertit les gradients sign√©s en valeurs absolues non sign√©es 8-bit pour pouvoir afficher (valeurs positives entre 0 et 255).
abs_grad_y = cv.convertScaleAbs(grad_y) # Mega important il prend la abs de la variation des bords
    
    
grad = cv.addWeighted(abs_grad_x, 0.5, abs_grad_y, 0.5, 0)#Combine les gradients avec un poids de 0.5 chacun pour obtenir une image finale des bords dans toutes les directions.
                                                            # le 0 est une valeur a add a la fin ( + grand + claire)
plt.imshow(grad, cmap = 'gray')
plt.axis('off')  # Hide axes
plt.show()
           </code></pre>
      </details>



  <hr>
  <h1> D√©rive seconde (de Laplace)</h1>

<p>
  Le Laplacien est un op√©rateur diff√©rentiel qui mesure la variation d‚Äôintensit√© dans toutes les directions.  
  Il est bas√© sur la **d√©riv√©e seconde** et est tr√®s sensible aux changements rapides d‚Äôintensit√©, donc aux bords.
</p>

<h3>Convolution avec un kernel</h3>
<p>
  On calcule la convolution de l‚Äôimage \(I\) avec un kernel \(K\) pour obtenir le Laplacien :

\[
L = K * I
\]
</p>
<h3>Kernel du Laplacien (exemple 3x3)</h3>

<p><b>Kx :</b>
\[
K_x =
\begin{bmatrix}
0 & 1 & 0 \\
1 & -4 & 1 \\
0 & 1 & 0
\end{bmatrix}
\]
</p>
<p><b>Ky :</b> (optionnel pour direction verticale ou diagonales) 
\[
K_y =
\begin{bmatrix}
1 & 0 & 1 \\
0 & -4 & 0 \\
1 & 0 & 1
\end{bmatrix}
\]
</p>
<p>
  Chaque pixel de la nouvelle image \(L\) est obtenu en faisant la somme pond√©r√©e des pixels voisins selon le kernel.  
  Les valeurs n√©gatives indiquent des transitions vers des intensit√©s plus faibles et les valeurs positives vers des intensit√©s plus √©lev√©es.  
  Les bords apparaissent donc comme des zones avec des valeurs extr√™mes.
</p>

<p>
  Contrairement √† Sobel ou Scharr, le Laplacien ne fournit pas de direction du gradient ; il met en √©vidence les zones de variation rapide d‚Äôintensit√©.
</p>

<h3>Exemple</h3>

  <img src="laplace.png"> 
        <div class="legend">
            <p>
                D√©riv√© seconde respectivement avec Laplacian() et 2 x Sobel() 
            </p>
        </div>

       <details>    
        <summary> <b style="color: red;">Partie Laplace Python</b>
            </summary>
        <pre><button class="copy-btn" onclick="copyCode()">Copier</button><code id="code-block">
grad_xx = cv.Sobel(gray, cv.CV_64F, 2, 0, ksize=5)  # ‚àÇ¬≤/‚àÇx¬≤
grad_yy = cv.Sobel(gray, cv.CV_64F, 0, 2, ksize=5)  # ‚àÇ¬≤/‚àÇy¬≤

laplacian_manual = grad_xx*0.5 + grad_yy*0.5

abs_dst_manu = cv.convertScaleAbs(laplacian_manual)

laplacian = cv.Laplacian(gray, cv.CV_64F, ksize=3)

# converting back to uint8 
abs_dst = cv.convertScaleAbs(laplacian)

plt.subplot(121)
plt.imshow(abs_dst*5, cmap='gray')
plt.subplot(122)
plt.imshow(abs_dst_manu, cmap='gray')
plt.axis('off')
plt.show()
 </code></pre>
      </details>

<hr>
  <h1>D√©tecteur de bords Canny</h1>

<p>
  Le d√©tecteur de Canny est consid√©r√© comme un d√©tecteur de bords optimal. Il combine plusieurs √©tapes pour extraire les contours d'une image de mani√®re pr√©cise et robuste au bruit.
</p>

<h3> Calcul du gradient</h3>
<p>
  Comme pour Sobel, on calcule les d√©riv√©es horizontales \(G_x\) et verticales \(G_y\) via une convolution :


\[
G_x = K_x * I, \quad G_y = K_y * I
\]
</p>
<p>
  Puis on calcule la magnitude du gradient et la direction du bord :

\[
G = \sqrt{G_x^2 + G_y^2}, \quad
\Theta = \arctan\left(\frac{G_y}{G_x}\right)
\]
</p>
<p>
  La direction \(\Theta\) est ensuite arrondie √† 0¬∞, 45¬∞, 90¬∞ ou 135¬∞ pour simplifier l'analyse des bords.
</p>

<h3>Non-maximum suppression</h3>
<p>
  Chaque pixel est compar√© √† ses voisins le long de la direction du gradient.  
  Si le pixel n‚Äôest pas un maximum local, il est supprim√© (mis √† z√©ro).  
  Cela permet d‚Äôobtenir des bords fins d‚Äôune seule pixel de largeur.
</p>

<h3>Double seuillage (Hysteresis)</h3>
<p>
  On d√©finit deux seuils : <em>low</em> et<em> high</em> (typiquement ratio entre 2:1 et 3:1).  
</p>
<ul>
  <li>Si la magnitude du gradient du pixel est > high ‚Üí pixel consid√©r√© comme bord.</li>
  <li>Si < low ‚Üí pixel rejet√©.</li>
  <li>Si entre low et high ‚Üí pixel conserv√© seulement s‚Äôil est connect√© √† un pixel d√©j√† consid√©r√© comme bord.</li>
</ul>

<p>
  Cette technique de double seuil permet d‚Äô√©liminer le bruit tout en conservant la continuit√© des bords.
</p>

<h3>Exemple</h3>

  <img src="canny.png"> 
        <div class="legend">
            <p>
                D√©riv√© Canny() 
            </p>
        </div>

       <details>    
        <summary> <b style="color: red;">Partie Canny Python</b>
            </summary>
        <pre><button class="copy-btn" onclick="copyCode()">Copier</button><code id="code-block">
detected_edges = cv.Canny(gray, 50,50*3, 3) #cv.Canny(img_blur, thresh_bas, thresh_haut,ksize)

mask = detected_edges != 0 # On cr√©e un masque bool√©en : True l√† o√π un bord a √©t√© d√©tect√© (!= 0), et False ailleurs. --> deja "fini" 

dst = src * (mask[:,:,None].astype(src.dtype)) # prend image de base et on la passe devant le mask (mis en dimension 3 pour pouvoir faire multiplication) >> pour avoir couleurs image de base
print(src.shape)

plt.subplot(121)
plt.imshow(src)
plt.subplot(122)
plt.imshow(mask, cmap='gray')
plt.axis('off')
plt.show()
 </code></pre>
      </details>

      <h3>Manuellement</h3>

    <img src="canny_manual.png"> 
        <div class="legend">
            <p>
                D√©riv√© Canny() 
            </p>
        </div>

       <details>    
        <summary> <b style="color: red;">Partie Canny Manuel Python</b>
            </summary>
        <pre><button class="copy-btn" onclick="copyCode()">Copier</button><code id="code-block">
magnitude = grad

theta = np.arctan2(grad_y, grad_x) * 180 / np.pi # en degres
theta[theta < 0] += 180  # On garde les angles entre 0¬∞ et 180¬∞

nms = np.zeros_like(magnitude) # tableau de 0 de mm forme que magnitude

for i in range(1, magnitude.shape[0] - 1):
    for j in range(1, magnitude.shape[1] - 1):
        angle = theta[i, j]

        q = 255
        r = 255

        # Approximer l'angle pour comparer les bons voisins
        if (0 <= angle < 45) :
            q = magnitude[i, j + 1]
            r = magnitude[i, j - 1]
        elif 45 <= angle < 90:
            q = magnitude[i + 1, j - 1]
            r = magnitude[i - 1, j + 1]
        elif 90 <= angle < 135:
            q = magnitude[i + 1, j]
            r = magnitude[i - 1, j]
        elif 135 <= angle < 180:
            q = magnitude[i - 1, j - 1]
            r = magnitude[i + 1, j + 1]

        if magnitude[i, j] >= q and magnitude[i, j] >= r:
            nms[i, j] = magnitude[i, j]
        else:
            nms[i, j] = 0

low_thresh = 100
high_thresh = 200


#double seuillage
res = np.zeros_like(nms)
strong = 255
weak = 50

strong_i, strong_j = np.where(nms >= high_thresh)
weak_i, weak_j = np.where((nms >= low_thresh) & (nms < high_thresh))

res[strong_i, strong_j] = strong
res[weak_i, weak_j] = weak

# connexion bords faibles
for i in range(1, res.shape[0] - 1):
    for j in range(1, res.shape[1] - 1):
        if res[i, j] == weak:
            if np.any(res[i-1:i+2, j-1:j+2] == strong):
                res[i, j] = strong
            else:
                res[i, j] = 0


plt.imshow(res, cmap = 'gray')
plt.axis('off')  # Hide axes
plt.show()
 </code></pre>
      </details>

    </main>
</div>

<footer>
    ¬© 2025 - Guillaume Dengreville
</footer>

</body>

</html>

