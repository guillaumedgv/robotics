<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Watershed</title>
  <link rel="stylesheet" href="../style.css">
</head>
<body>

  <!-- Navbar dynamique -->
  <div id="navbar"></div>

  <!-- --- MathJax for LaTeX equations --- -->
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>

  <script>
  // Load navbar dynamically from external file
  fetch("navbar_vision.html")
    .then(response => response.text())  // Read the content as text
    .then(data => {
      // Insert the navbar HTML into the page
      document.getElementById("navbar").innerHTML = data;

      // ----------------------------
      // Highlight the current page
      // ----------------------------
      const currentPath = window.location.pathname;  // e.g., "/index.html"
      const links = document.querySelectorAll("#navbar nav a"); // all nav links

      links.forEach(link => {
        const href = link.getAttribute("href");
        if (!href) return; // Skip links without href

        // Normalize paths (remove leading slash) to compare properly
        const normalizedHref = href.replace(/^\//, "");
        const normalizedPath = currentPath.replace(/^\//, "");

        if (normalizedPath.endsWith(normalizedHref)) {
          // ‚úÖ Mark link of current page as active
          link.classList.add("active");

          // If the link is in a submenu, also highlight its parent
          const parentLi = link.closest("ul")?.closest("li");
          if (parentLi) {
            const parentLink = parentLi.querySelector(":scope > a");
            if (parentLink) parentLink.classList.add("active-parent");
          }
        } else {
          // Remove active class from other links
          link.classList.remove("active");
        }
      });

      // ----------------------------
      // Night mode toggle button
      // ----------------------------
      const themeToggle = document.getElementById("themeToggle");

      // On page load, check if user previously enabled night mode
      if (localStorage.getItem("nightMode") === "true") {
        document.body.classList.add("night");
        if (themeToggle) themeToggle.textContent = "‚òÄÔ∏è Day Mode";
      }

      // Set up click listener for the button
      if (themeToggle) {
        themeToggle.addEventListener("click", () => {
          document.body.classList.toggle("night"); // Toggle night mode

          // Save current mode in localStorage to persist across pages
          const isNight = document.body.classList.contains("night");
          localStorage.setItem("nightMode", isNight);

          // Update button text based on current mode
          themeToggle.textContent = isNight ? "‚òÄÔ∏è Day Mode" : "üåô Night Mode";
        });
      }
    })
    .catch(error => console.error("Erreur chargement navbar :", error));
</script>


<div class="container">
    <!-- Contenu principal -->
    <aside class="sidebar">
      <h3>Vision par Ordinateur</h3>
      <ul>
        <ul>
        <li><a href="Transformation_Morpho.html">Transformation Morphologique</a></li>
        <li><a href="Pattern_Reconnaissance.html">Reconnaissance de motifs </a></li>
        <li><a href="Derive.html">D√©riv√©</a></li>
        <li><a href="Hough.html">Transform√© de Hough </a></li>
        <li><a href="Extract_line.html">Extraction de lignes</a></li>
        <li><a href="Convex_hull.html">Enveloppe convexe</a></li>
        <li><a href="polygone.html">Distance aux contours & Moments</a></li>
        <li><a href="remappinge.html">Remapping</a></li>
        <li><a href="affine_dft.html" >Transformation affine & DFT</a></li>
        <li><a href="Watershed.html" class="active">Algorithme Watershed</a></li>

      </ul>
      </ul>
    </aside> 

    <main class="content">


        <h1>Principe de l‚Äôalgorithme Watershed</h1>

        <p>
        L‚Äôalgorithme <b>Watershed</b> (ligne de partage des eaux) est une m√©thode de
        segmentation d‚Äôimages bas√©e sur une analogie topographique.
        L‚Äôimage est interpr√©t√©e comme une surface en relief o√π l‚Äôintensit√©
        des pixels repr√©sente l‚Äôaltitude.
        </p>

        <p>
        Les zones de faible intensit√© correspondent √† des <i>bassins</i>,
        tandis que les zones de forte intensit√© repr√©sentent des <i>cr√™tes</i>.
        L‚Äôobjectif est de s√©parer automatiquement les r√©gions adjacentes.
        </p>

        <h3>Pr√©traitement de l‚Äôimage</h3>

        <p>
        L‚Äôimage est d‚Äôabord convertie en niveaux de gris, puis filtr√©e
        (par exemple avec un flou gaussien) afin de r√©duire le bruit :
        </p>


        <p>
        o√π \(G_{\sigma}\) est un noyau gaussien de variance \(\sigma\).
        </p>

        <img src="watershed_extract_item.png">
        <div class="legend">
            <p>
                Pr√©traitement de l'image
            </p>
        </div>

        <p>
            Apr√®s avoir fait un flou gaussien les bords des objets sont souvent peu net.
            On utilise souvent une d√©riv√© seconde pour les renforcer
        </p>

        <img src="watershed_derive_seconde.png">
        <div class="legend">
            <p>
                Am√©lioration des bords de l'image
            </p>
        </div>
        

        <h3>Binarisation</h3>

        <p>
        Une image binaire est obtenue par seuillage. Le fait qu'elle ne soit pas net est un effet
        recherch√© en fonction des sujets pour cr√©er un seul marqueur par objet (commme expliquer ci-dessous)
        </p>

        </p>

        <img src="watershed_binaire.png">
        <div class="legend">
            <p>
                Binarisation de l'image
            </p>
        </div>

        <h3>Transformation de distance</h3>

        <p>
        OpenCV utilise la <b>distance transform</b> pour estimer la distance de
        chaque pixel d‚Äôobjet au pixel de fond le plus proche :
        </p>

        <p>
        $$
        D(x,y) = \min_{(x',y') \in \text{fond}} \sqrt{(x-x')^2 + (y-y')^2}
        $$
        </p>

        <p>
        Les maxima locaux de cette carte correspondent g√©n√©ralement au centre
        des objets.
        </p>

        <img src="watershed_dist_transform.png">
        <div class="legend">
            <p>
                Evaluation de la distance des pixels aux bords
            </p>
        </div>


        <h3>D√©finition des marqueurs</h3>

        <p>
        Les marqueurs sont des r√©gions initiales √† partir desquelles
        le remplissage va commencer.
        On distingue :
        </p>

        <ul>
        <li>les marqueurs de premier plan (objets s√ªrs)</li>
        <li>les marqueurs d‚Äôarri√®re-plan (fond s√ªr)</li>
        </ul>

        <p>
            Pour les marqueurs objet on utilise un seuillage de l'√©valuation de distance fait 
            pr√©c√©dement. C'est donc important d'avoir seulement un marqueur par objet et donc d'adapter
            le pr√©-traitement en fonction de l'image.
        </p>

        <img src="watershed_dist_peak.png">
        <div class="legend">
            <p>
                Seuillage pour d√©finir les marqueurs premier plan
            </p>
        </div>

        <p>
            Le marqueur de fond est generalement juste plac√© arbitrairement l√† ou il n'y a 
            jamais d'objets.
        </p>
      

        <h3>Application de l‚Äôalgorithme Watershed</h3>

        <p>
        La fonction <em>watershed</em> traite l‚Äôimage comme une surface
        topographique.
        Les bassins sont remplis progressivement √† partir des marqueurs,
        jusqu‚Äô√† ce que deux bassins entrent en collision.
        </p>

        <p>
        Les pixels situ√©s sur ces fronti√®res sont marqu√©s comme lignes de
        s√©paration :
        </p>

        <p>
        $$
        W(x,y) = -1
        $$
        </p>

        <p>
        Ces lignes correspondent aux contours des objets segment√©s.
        </p>

        <h3>R√©sultat final</h3> 

        <p>
        Chaque r√©gion segment√©e poss√®de une √©tiquette distincte.
        Les fronti√®res issues du watershed permettent une s√©paration pr√©cise
        des objets m√™me lorsqu‚Äôils sont coll√©s ou se chevauchent.
        </p>

        <p>
        Cette m√©thode est particuli√®rement efficace pour la segmentation
        d‚Äôobjets biologiques, de cellules ou de particules en vision par ordinateur.
        </p>




        <img src="watershed_result.png">
        <div class="legend">
            <p>
                Resultat de l'algorithme watershed
            </p>
        </div>


        <details>    
        <summary> <b style="color: red;">Algorithme Watershed en Python</b>
            </summary>
        <pre><button class="copy-btn" onclick="copyCode()">Copier</button><code id="code-block">
import cv2 as cv
import numpy as np
import argparse
import random as rng
import matplotlib.pyplot as plt

src = cv.imread('carte.jpg')
src_rgb = cv.cvtColor(src, cv.COLOR_BGR2RGB)


#src = cv.resize(src, (src.shape[1]//4, src.shape[0]//4))
#src_rgb = cv.resize(src_rgb, (src_rgb.shape[1]//4, src_rgb.shape[0]//4))


gray = cv.cvtColor(src, cv.COLOR_BGR2GRAY)
gray = cv.GaussianBlur(gray,(3,3),0)
_, thresh = cv.threshold(gray,240, 255, cv.THRESH_BINARY) #si pixel valeur au dessus de 250 met la valeur a 255 

thresh = ~thresh # --> objet en blanc !

plt.imshow(thresh, cmap = 'gray')
plt.axis('off')  # Hide axes
plt.show()

#Trouver les contousr externes
contours, _ = cv.findContours(thresh, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE)

# Cr√©er un masque noir
mask = np.zeros_like(gray)

# Dessiner le contour externe dans le masque (rempli = -1)
cv.drawContours(mask, contours, -1, 255, thickness=cv.FILLED)



# Appliquer le masque sur chaque canal RGB
masked = cv.bitwise_and(src_rgb, src_rgb, mask=mask) # √ßa garde l‚Äôimage l√† o√π mask == 255, et met le reste √† noir 

# src_rgb[np.all(src_rgb == 255, axis=2)] = 0 >>  peut marcher aussi 

#  Affichage
plt.imshow(masked, cmap ='gray')
plt.axis('off')  # Hide axes
plt.show()

kernel = np.array([[1, 1, 1], [1, -8, 1], [1, 1, 1]], dtype=np.float32) # appro deriv√© seconde

imgLaplacian = cv.filter2D(masked, cv.CV_32F, kernel) # image des bords du coup
original = np.float32(masked)
imgResult = original - imgLaplacian

# convert back to 8bits gray scale
imgResult = np.clip(imgResult, 0, 255) # limite les valeurs en 0 et 255
imgResult = imgResult.astype('uint8') # image en couleur
imgLaplacian = np.clip(imgLaplacian, 0, 255)
imgLaplacian = np.uint8(imgLaplacian)

plt.imshow(imgLaplacian)
plt.axis('off')  # Hide axes
plt.show()

plt.imshow(imgResult)
plt.axis('off')  # Hide axes
plt.show()

# Convertir en niveaux de gris
bw = cv.cvtColor(imgResult, cv.COLOR_BGR2GRAY)

blur = cv.GaussianBlur(bw, (3, 3), 0)

_, bw = cv.threshold(blur, 240, 255, cv.THRESH_BINARY)

ker = np.ones((3 ,3), np.uint8)

bw = cv.morphologyEx(bw, cv.MORPH_CLOSE,ker)

#bw = cv.resize(bw, (bw.shape[1]//4, bw.shape[0]//4))  # reduit la taille image par 4 si on a pas assez de place memoire

#  Afficher l'image binaire
plt.imshow(bw, cmap='gray')   
plt.axis('off')
plt.title("Binary Image")
plt.show()

# Appliquer la transformation de distance
dist = cv.distanceTransform(bw, distanceType=cv.DIST_L2, maskSize=3)# distance au pixel noir le plus proche dans une image binaire, cv.DIST_L2 : utilise la distance euclidienne

# Normaliser pour affichage (entre 0 et 1.0)
dist_norm = cv.normalize(dist, None, 0.1, 1.0, cv.NORM_MINMAX, dtype=cv.CV_32F) # val_norm = val - min / max - min 

# Afficher la carte de distance
plt.imshow(dist_norm, cmap='jet')  # cmap='jet' donne un beau d√©grad√©
plt.axis('off')
plt.title("Distance Transform")
plt.show()

# Threshold to obtain the peaks
# This will be the markers for the foreground objects
_, dist_norm = cv.threshold(dist_norm, 0.4, 255, cv.THRESH_BINARY) # threshold pour les distance, si au dessus de 0.35 -> pixel val 255
# Dilate a bit the dist image
kernel1 = np.ones((3,3), dtype=np.uint8)
dist_norm = cv.erode(dist_norm, kernel1)

plt.imshow(dist_norm, cmap ='gray') 
plt.axis('off')
plt.title("Distance Transform")
plt.show()

# Convertir en image 8 bits pour findContours
dist_8u = (dist_norm).astype('uint8')

# Trouver les contours sur la carte de distance seuill√©e
contours, _ = cv.findContours(dist_8u, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE) # contours des centres

# Cr√©er l'image de marqueurs pour watershed
markers = np.zeros(dist_norm.shape, dtype=np.int32) 

# Dessiner chaque objet comme un marqueur diff√©rent
for i in range(len(contours)):
    cv.drawContours(markers, contours, i, i + 1, -1)  #Dessine le i·µâ contour dans l'image markers, et remplis-le avec la valeur i+1 (0 pour le fond), le -1 veut dire contours filled

# Ajouter un marqueur pour d√©finir le fond (coin haut gauche par exemple)
cv.circle(markers, (5, 5), 3, 255, -1)  # 255 = fond >> arbitraire ici car OpenCV ignore les valeurs > len(contours) 

# Visualiser les marqueurs (optionnel)
markers_8u = (markers).astype('uint8')  # Pour visualiser
plt.imshow(markers_8u, cmap='gray')
plt.axis('off')
plt.title("Markers for Watershed")
plt.show()


# Appliquer Watershed
cv.watershed(imgResult, markers) # imgResult doit etre en couleur, on ecrit le resultat dans marker

# G√©n√©rer des couleurs al√©atoires
colors = [tuple(rng.randint(0, 255) for _ in range(3)) for _ in contours]

# Image de sortie en couleur
dst = np.zeros((markers.shape[0], markers.shape[1], 3), dtype=np.uint8)

# Colorer les r√©gions identifi√©es
for i in range(markers.shape[0]):
    for j in range(markers.shape[1]):
        index = markers[i, j]
        if index > 0 and index <= len(contours):
            dst[i, j] = colors[index - 1]
        elif index == -1:
            dst[i, j] = [255, 255, 255]  # Bords de Watershed

# Afficher avec matplotlib
plt.imshow(cv.cvtColor(dst, cv.COLOR_BGR2RGB))
plt.axis('off')
plt.title("Watershed Result")
plt.show()
            </code></pre>
    </details>

    </main>
</div>

<footer>
    ¬© 2025 - Guillaume Dengreville
</footer>

</body>

</html>
