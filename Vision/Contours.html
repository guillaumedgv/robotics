<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Contours</title>
  <link rel="stylesheet" href="../style.css">
</head>
<body>

  <!-- Navbar dynamique -->
  <div id="navbar"></div>

  <!-- --- MathJax for LaTeX equations --- -->
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>

  <script>
  // Load navbar dynamically from external file
  fetch("navbar_vision.html")
    .then(response => response.text())  // Read the content as text
    .then(data => {
      // Insert the navbar HTML into the page
      document.getElementById("navbar").innerHTML = data;

      // ----------------------------
      // Highlight the current page
      // ----------------------------
      const currentPath = window.location.pathname;  // e.g., "/index.html"
      const links = document.querySelectorAll("#navbar nav a"); // all nav links

      links.forEach(link => {
        const href = link.getAttribute("href");
        if (!href) return; // Skip links without href

        // Normalize paths (remove leading slash) to compare properly
        const normalizedHref = href.replace(/^\//, "");
        const normalizedPath = currentPath.replace(/^\//, "");

        if (normalizedPath.endsWith(normalizedHref)) {
          // ‚úÖ Mark link of current page as active
          link.classList.add("active");

          // If the link is in a submenu, also highlight its parent
          const parentLi = link.closest("ul")?.closest("li");
          if (parentLi) {
            const parentLink = parentLi.querySelector(":scope > a");
            if (parentLink) parentLink.classList.add("active-parent");
          }
        } else {
          // Remove active class from other links
          link.classList.remove("active");
        }
      });

      // ----------------------------
      // Night mode toggle button
      // ----------------------------
      const themeToggle = document.getElementById("themeToggle");

      // On page load, check if user previously enabled night mode
      if (localStorage.getItem("nightMode") === "true") {
        document.body.classList.add("night");
        if (themeToggle) themeToggle.textContent = "‚òÄÔ∏è Day Mode";
      }

      // Set up click listener for the button
      if (themeToggle) {
        themeToggle.addEventListener("click", () => {
          document.body.classList.toggle("night"); // Toggle night mode

          // Save current mode in localStorage to persist across pages
          const isNight = document.body.classList.contains("night");
          localStorage.setItem("nightMode", isNight);

          // Update button text based on current mode
          themeToggle.textContent = isNight ? "‚òÄÔ∏è Day Mode" : "üåô Night Mode";
        });
      }
    })
    .catch(error => console.error("Erreur chargement navbar :", error));
</script>


<div class="container">
    <!-- Contenu principal -->
    <aside class="sidebar">
      <h3>Vision par Ordinateur</h3>
      <ul>
        <ul>
        <li><a href="Transformation_Morpho.html">Transformation Morphologique</a></li>
        <li><a href="Pattern_Reconnaissance.html">Reconnaissance de motifs </a></li>
        <li><a href="Derive.html">D√©riv√©</a></li>
        <li><a href="Hough.html">Transform√© de Hough </a></li>
        <li><a href="Extract_line.html">Extraction de lignes</a></li>
        <li><a href="Convex_hull.html">Enveloppe convexe</a></li>
        <li><a href="polygone.html">Distance aux contours & Moments</a></li>
        <li><a href="remappinge.html">Remapping</a></li>
        <li><a href="affine_dft.html" >Transformation affine & DFT</a></li>
        <li><a href="Watershed.html" class="active">Algorithme Watershed</a></li>

      </ul>
      </ul>
    </aside> 

    <main class="content">

        <h1> Extraction des Contours</h1>

        <p>
            La d√©tection de contours en vision par ordinateur permet d‚Äôextraire une liste de formes 
            vectorielles √† partir d‚Äôune image, repr√©sentant les limites des objets d√©tect√©s. Ces contours 
            peuvent ensuite √™tre manipul√©s s√©par√©ment, ce qui facilite l‚Äôanalyse et le traitement de chaque 
            objet de mani√®re ind√©pendante. Gr√¢ce √† cette repr√©sentation, il est possible de mettre en 
            ≈ìuvre diverses applications telles que le tracking d‚Äôobjets, l‚Äôanalyse de la convexit√©, l‚Äôextraction 
            de caract√©ristiques (aire, p√©rim√®tre, forme), ou encore la cr√©ation de masques pour des traitements 
            locaux cibl√©s sur des r√©gions sp√©cifiques de l‚Äôimage. La d√©tection de contours constitue ainsi une 
            √©tape cl√© pour la compr√©hension de sc√®ne et l‚Äôanalyse g√©om√©trique en vision par ordinateur.
        </p>

        <p>
            Le principe est simple, on extrait les contours avec <em>Canny</em> on peut ensuite extraire les elements structurants avec <em>getStructuringElement</em>.
            A partir de l√† <em>findContours</em> fait le reste du travail.
        </p>

        <hr>

        <h1> Exemple :</h1>

        <img src="contours_forme.png">  
        <div class="legend">
            <p>
                Contours de forme avec <em>findContours</em> 
            </p>
        </div>

       <details>    
        <summary> <b style="color: red;">Extraction des contours sur Python</b>
            </summary>
        <pre><button class="copy-btn" onclick="copyCode()">Copier</button><code id="code-block">
import cv2 as cv
import numpy as np
import argparse
import random as rng
import matplotlib.pyplot as plt

src = cv.imread('formesdifferentes.png', cv.IMREAD_COLOR)

if src is None:
    print("Erreur : Image non charg√©e. V√©rifie le chemin du fichier.")
    exit()

gray = cv.cvtColor(src, cv.COLOR_BGR2GRAY)
gray = cv.GaussianBlur(gray, (5, 5), 0)
# Detect edges using Canny
canny_output = cv.Canny(gray, 50, 255)

# pas n√©c√©ssaire ici, mais peut etre utile
kernel = cv.getStructuringElement(cv.MORPH_RECT, (3, 3))
closed = cv.morphologyEx(canny_output, cv.MORPH_CLOSE, kernel) # pour enlever les d√©faut un avoir des contours smooth

copy = src.copy()

plt.imshow(closed, cmap = 'gray')
plt.axis('off')  # Hide axes
plt.show()

contours, hierarchy = cv.findContours(closed, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE) #  cv.RETR_TREE pour avoir tout les contours ()
print("Nombre de contours d√©tect√©s:", len(contours))

num=0

# Draw contours
drawing = np.zeros((canny_output.shape[0], canny_output.shape[1], 3), dtype=np.uint8)
for i in range(len(contours)):
    color = (0, 0, 255)
    cv.drawContours(drawing, contours, -1, (0, 255, 0), 2) # cv.drawContours(image, contours, contourIndex, color, thickness) -> -1 pour dessiner tous les objets


for cnt in contours:
    num += 1
    area = cv.contourArea(cnt) # superficie
    print("Aire :", area)
    perimeter = cv.arcLength(cnt, True) # perimetre
    print("p√©rimetre :", area)
    x, y, w, h = cv.boundingRect(cnt) # pour avoir un rectangle autour de l'objet
    cv.rectangle(copy, (x, y), (x+w, y+h), (255, 0, 0), 2) # on le dessine

    M = cv.moments(cnt) #calcul du moment
    if M["m00"] != 0:
        cx = int(M["m10"] / M["m00"])
        cy = int(M["m01"] / M["m00"])
        cv.circle(copy, (cx, cy), 4, (0, 0, 255), -1) # desine un cercle de raduis 4, plein (-1) au centre de masse de l'objet 

    cv.putText(copy, str(num), (x, y), cv.FONT_HERSHEY_SIMPLEX, 0.6, (0, 0, 255), 2) # pour num√©roter les objets, ici quelques un ce superpose

for contour in contours:
    approx = cv.approxPolyDP(contour, 0.04 * cv.arcLength(contour, True), True) # simplifier un contour en un polygone approch√©, 0.04 * cv.arcLength(contour, True) > pr√©cision simplification
    sommets = len(approx)

    x, y, w, h = cv.boundingRect(contour)

    if sommets == 3:
        print("Triangle")
        cv.putText(copy, "Triangle", (x+25, y - 5),
                   cv.FONT_HERSHEY_SIMPLEX, 0.4, (0, 0, 255), 1)

    elif sommets == 4:
        print("Carre ou rectangle")
        cv.putText(copy, "Carre/Rectangle", (x+25, y - 5),
                   cv.FONT_HERSHEY_SIMPLEX, 0.4, (0, 0, 255), 1)

    elif sommets > 4:
        print("Cercle ou autre")
        cv.putText(copy, "Cercle/Autre", (x +25, y - 5),
                   cv.FONT_HERSHEY_SIMPLEX, 0.4, (0, 0, 255), 1)

plt.imshow(drawing  , cmap = 'gray')
plt.axis('off')  # Hide axes
plt.show()

plt.imshow(copy  , cmap = 'gray')
plt.axis('off')  # Hide axes
plt.show()

             </code></pre>
      </details>

      <h3> Boite englobante</h3>

      <p>
        On peut aussi dessiner les contours approximatif, tracer des cercle ou encore des ellipse 
        autour de tout les contours ou seulement certain... 
      </p>

       <img src="bbox_before.png">    
        <div class="legend">
            <p>
                Pr√© traitement Contours Canny
            </p>
        </div>

        <img src="bbox.png">    
        <div class="legend">
            <p>
                Dessin des Contours de forme avec <em>fitEllipse, drawContours, approxPolyDP & boundingRect</em>
            </p>
        </div>

        <details>    
        <summary> <b style="color: red;">Differentes Boite englobante sur Python</b>
            </summary>
        <pre><button class="copy-btn" onclick="copyCode()">Copier</button><code id="code-block">
import cv2 as cv
import numpy as np
import argparse
import random as rng
import matplotlib.pyplot as plt

# classique canny

img = cv.imread('image.png', cv.IMREAD_COLOR)  

gray = cv.cvtColor(img, cv.COLOR_BGR2GRAY)
gray = cv.GaussianBlur(gray, (7, 7), 0)

kernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, (5, 5))

threshold = 50
    
canny = cv.Canny(gray, threshold, threshold * 3)

plt.subplot(121)
plt.imshow(img, cmap = 'gray')
plt.axis('off')  # Hide axes
plt.subplot(122)
plt.imshow(canny , cmap = 'gray')
plt.axis('off')  # Hide axes
plt.show()

copy = img.copy()

contours, hierarchy = cv.findContours(canny, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE)  # trouve les contours pour pouvoir manipuler

drawing = np.zeros((canny.shape[0], canny.shape[1], 3), dtype=np.uint8) # si on veut dessiner dans une nouvelle image



#centers = [None]*len(contours) # si in veut un cercle
#radius = [None]*len(contours)
contours_poly = [None]*len(contours)   
minRect = [None]*len(contours) # prepare les list pour les contours
minEllipse = [None]*len(contours)

for i, c in enumerate(contours): # i is the index of the current contour c in the contours list et c -> (number_of_points, 1, 2)

    color = (rng.randint(0,256), rng.randint(0,256), rng.randint(0,256))

    contours_poly[i] = cv.approxPolyDP(c, 3, True)    # avoir des contour plus simple visuelement 
    cv.drawContours(copy, contours_poly, i, color,2)
    

    minRect[i] = cv.minAreaRect(c) # on trouve le plus petit rectangle pour entourer le contour i       
    box = cv.boxPoints(minRect[i]) # coord x,y des bord
    box = np.intp(box)  # met en int

    if c.shape[0] > 5: # doit avoir plus de 5 pts pour une ellipse
        minEllipse[i] = cv.fitEllipse(c) # pareil mais une ellipse

    # Define an axis-aligned rectangular ROI (inutile ici mais sympa pour image plus grande)
    x_roi, y_roi, w_roi, h_roi = 0, 0, 700, 400

    x, y, w, h = cv.boundingRect(c)
    cx = x + w // 2
    cy = y + h // 2
    point = (cx, cy) # centre des rect pour check roi

    #centers[i], radius[i] = cv.minEnclosingCircle(contours_poly[i]) # pour le cercle

    if x_roi <= cx <= x_roi + w_roi and y_roi <= cy <= y_roi + h_roi:

        if c.shape[0] > 50:

            cv.drawContours(copy, [box], 0, color, 2)
        
            cv.ellipse(copy, minEllipse[i], color, 2)
            # cv.circle(drawing, (int(centers[i][0]), int(centers[i][1])), int(radius[i]), color, 2)
    
plt.imshow(copy)
             </code></pre>
      </details>

    </main>
</div>

<footer>
    ¬© 2025 - Guillaume Dengreville
</footer>

</body>

</html>

