<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Robot Self Balancing</title>
  <link rel="stylesheet" href="../style.css">
</head>
<body>

  <!-- Navbar dynamique -->
  <div id="navbar"></div>

  <!-- --- MathJax for LaTeX equations --- -->
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>

  <script>
  // Load navbar dynamically from external file
  fetch("navbar_projet.html")
    .then(response => response.text())  // Read the content as text
    .then(data => {
      // Insert the navbar HTML into the page
      document.getElementById("navbar").innerHTML = data;

      // ----------------------------
      // Highlight the current page
      // ----------------------------
      const currentPath = window.location.pathname;  // e.g., "/index.html"
      const links = document.querySelectorAll("#navbar nav a"); // all nav links

      links.forEach(link => {
        const href = link.getAttribute("href");
        if (!href) return; // Skip links without href

        // Normalize paths (remove leading slash) to compare properly
        const normalizedHref = href.replace(/^\//, "");
        const normalizedPath = currentPath.replace(/^\//, "");

        if (normalizedPath.endsWith(normalizedHref)) {
          // ‚úÖ Mark link of current page as active
          link.classList.add("active");

          // If the link is in a submenu, also highlight its parent
          const parentLi = link.closest("ul")?.closest("li");
          if (parentLi) {
            const parentLink = parentLi.querySelector(":scope > a");
            if (parentLink) parentLink.classList.add("active-parent");
          }
        } else {
          // Remove active class from other links
          link.classList.remove("active");
        }
      });

      // ----------------------------
      // Night mode toggle button
      // ----------------------------
      const themeToggle = document.getElementById("themeToggle");

      // On page load, check if user previously enabled night mode
      if (localStorage.getItem("nightMode") === "true") {
        document.body.classList.add("night");
        if (themeToggle) themeToggle.textContent = "‚òÄÔ∏è Day Mode";
      }

      // Set up click listener for the button
      if (themeToggle) {
        themeToggle.addEventListener("click", () => {
          document.body.classList.toggle("night"); // Toggle night mode

          // Save current mode in localStorage to persist across pages
          const isNight = document.body.classList.contains("night");
          localStorage.setItem("nightMode", isNight);

          // Update button text based on current mode
          themeToggle.textContent = isNight ? "‚òÄÔ∏è Day Mode" : "üåô Night Mode";
        });
      }
    })
    .catch(error => console.error("Erreur chargement navbar :", error));
</script>


<div class="container">
    <!-- Contenu principal -->
    <main class="content">

        <h1>
            Robot Auto Balanc√©
        </h1>

        <p>
           Dans le cadre de mes travaux en robotique, j‚Äôai souhait√© concevoir un robot mobile 
           pr√©sentant un r√©el int√©r√™t p√©dagogique. En effet, un robot mobile √† quatres roues 
           sans fonctionnalit√© sp√©cifique, offre un int√©r√™t limit√© en mati√®re d‚Äôapprentissage 
           et d‚Äôexp√©rimentation. J‚Äôai donc orient√© mon projet vers la r√©alisation d‚Äôun robot 
           auto-balanc√©, permettant d‚Äôaborder des notions avanc√©es telles que la r√©gulation 
           automatique, la stabilit√© dynamique et le contr√¥le en temps r√©el.
        </p>

        <p>
            Disposant d‚Äôune cam√©ra Raspberry Pi Module 3 inutilis√©e lors de projets pr√©c√©dents, 
            j‚Äôai √©galement choisi d‚Äôint√©grer un syst√®me de vision embarqu√©. Afin d‚Äôam√©liorer 
            la qualit√© des images et d‚Äôexploiter davantage les capacit√©s du dispositif, cette 
            cam√©ra devait √™tre mont√©e sur un stabilisateur con√ßu par mes soins lui aussi 
            permettant de compenser les mouvements du robot
        </p>  

        <div class="highlight">
        <p>
          On trouve nombre de vid√©o sur Youtube avec ce m√™me projet, qui utilise pour la plupart tous le m√™me 
          software et hardware. Pour ma part j'ai d√©cid√© de faire toute la conception et la partie logiciel moi m√™me, pour le meilleur et pour le pire.
        </p>
        </div>

        <p>
        <br>
      </p>


        <hr>

        <h3> Hardware</h3>

        <p>
            Le gimbal est √©quip√© de 2 servomoteurs
            <a href=https://www.amazon.fr/dp/B088NB5Y27?ref=ppx_yo2ov_dt_b_fed_asin_title>  MG996R</a>
            , pilot√©s par une carte driver 
            <a href=https://www.amazon.fr/dp/B0BKZC1XWR?ref=ppx_yo2ov_dt_b_fed_asin_title>  PCA9685</a>
            , et supporte une
            <a href=https://www.amazon.fr/dp/B0BRY6MVXL?ref=ppx_yo2ov_dt_b_fed_asin_title&th=1>  cam√©ra Raspberry Pi Module 3</a>
             Cette cam√©ra filme en <em>1920√ó1080</em> sans possibilit√© de r√©duire
            la r√©solution, ce qui n√©cessite une Raspberry Pi suffisamment puissante pour traiter la vid√©o.
        </p>

        <p>
            Le robot utilise une 
            <a href=https://www.amazon.fr/dp/B0CK2FCG1K?ref=ppx_yo2ov_dt_b_fed_asin_title>  Raspberry Pi 5 avec 8 Go de RAM</a>.
             Le syst√®me √©tant totalement autonome,
            tous les composants sont aliment√©s par batteries. Une 
            <a href=https://www.amazon.fr/dp/B09YCY1MX1?ref=ppx_yo2ov_dt_b_fed_asin_title&th=1>  alimentation 6 V</a>
            est d√©di√©e aux servomoteurs,
            tandis qu‚Äôune source 
            <a href=https://www.amazon.fr/dp/B0DXPWDZWQ?ref=ppx_yo2ov_dt_b_fed_asin_title>  source 12V/5A</a>
            alimente la Raspberry Pi via un
            <a href=https://www.amazon.fr/dp/B099DK7WS9?ref=ppx_yo2ov_dt_b_fed_asin_title>  abaisseur de tension</a>.
        </p>

        <p>
            La batterie 12V alimente aussi les 2 moteurs pas √† pas 
            <a href=https://www.amazon.fr/dp/B00PNEQKC0?ref=ppx_yo2ov_dt_b_fed_asin_title> NEMA 17</a>
            , contr√¥l√©s par des drivers
            <a href=https://www.amazon.fr/dp/B07C2V9GWC?ref=ppx_yo2ov_dt_b_fed_asin_title&th=1> A4988</a>,
            permettant une gestion pr√©cise du mouvement avec la possibilit√© de faire du microstepping.
        </p>

        <p>
            Pour mesurer l‚Äôorientation du robot dans l‚Äôespace (inclinaison et mouvement), un capteur 
            <a href=https://www.amazon.fr/dp/B0CLS2JY43?ref=ppx_yo2ov_dt_b_fed_asin_title> MPU6050</a>
            (gyroscope et acc√©l√©rom√®tre) est utilis√© afin de fournir les donn√©es n√©cessaires √† l‚Äô√©quilibrage.
        </p>


        <p>
        <br>
      </p>

        <hr>

        

        <h3>
            Partie Gimball & Tracking
        </h3>

        <p>
        Le programme de gimball & de tracking contr√¥le une cam√©ra mont√©e sur un syst√®me 
        Pan/Tilt motoris√© par deux servomoteurs. Il permet deux modes de fonctionnement : 
        un mode manuel avec boutons directionnels et un mode automatique o√π la cam√©ra suit 
        un objet circulaire d√©tect√© dans l‚Äôimage gr√¢ce √† la vision par ordinateur. 
        </p>

        <img src="vu_front_self.jpg" alt="Vue Face">
            <div class="legend">
                    <p>Vu de face du robot avec en haut la partie Gimball</p>
            </div> 

        <p>
        Le script commence par importer toutes les biblioth√®ques n√©cessaires : 
        gestion des servos via <em><b>ServoKit</b></em>, interface graphique via 
        <b><em>Tkinter</b></em>, capture vid√©o avec <b><em>Picamera2</b></em>, 
        traitement d‚Äôimage avec <b><em>OpenCV</b></em>, et gestion de fichiers. On 
        apelle le script "gyro.py" en parall√®le pour fournir en continu les valeurs de 
        roulis et tangage du gyroscope, √©crites dans un fichier texte.
        </p>

        <details >    
        <summary > <b style="color: red;">Programme gyroscope sur Python</b>
            </summary >
        <pre><button class="copy-btn" onclick="copyCode()">Copier</button><code id="code-block">    

             </code></pre>
      </details>

        <p>
        Ensuite, le programme configure les servomoteurs Pan et Tilt, charge les derniers 
        angles sauvegard√©s et r√©applique ces valeurs afin de restaurer la position pr√©c√©dente 
        de la cam√©ra. 
        </p>

        <p>
        On met en place l‚Äôinterface graphique Tkinter ensuite; Elle affiche le flux vid√©o en 
        direct depuis la cam√©ra et propose des boutons fl√©ch√©s permettant de contr√¥ler les 
        mouvements de la cam√©ra manuellement (lorsque l‚Äôutilisateur maintient un bouton enfonc√©, 
        la cam√©ra se d√©place continuellement dans la direction choisie). Durant ces mouvements 
        manuels, on d√©sactive la stabilisation gyroscopique est temporairement afin d‚Äô√©viter 
        des contre-mouvements ind√©sirables.
        </p>

        VIDEO STABILISATION GIMBALL

        <p>
        La stabilisation gyroscopique fonctionne en mode manuel en lisant les valeurs du 
        gyroscope, puis en corrigeant automatiquement l‚Äôangle des servos pour compenser les 
        mouvements de la base. Cette compensation se fait en soustrayant le roulis au servo 
        Pan et en ajoutant le tangage au servo Tilt.
        </p>

        <p>
        En mode automatique, on analyse l‚Äôimage et d√©tecter un cercle gr√¢ce √† l‚Äôalgorithme de 
        HoughCircles (ou recherche de cercle par transform√© de hough en francais). Une fois 
        d√©tect√©, le plus grand des cercles visible est choisi comme cible. Le contr√¥leur 
        proportionnel calcule alors les √©carts entre la position du cercle et le centre de 
        l‚Äôimage, puis ajuste automatiquement les servos Pan et Tilt pour recentrer la cible √† l‚Äô√©cran. 
        </p>

        <video controls>
          <source src="soft_tracking.mp4" type="video/mp4">
          Votre navigateur ne supporte pas la lecture vid√©o.
        </video>
        <div class="legend">
                    <p>Fenetre Tkinter avec vu de la cam√©ra et panneau de contr√¥le</p>
            </div> 

        <p>
          Vue de l'exterieur : 
        </p>

        <video controls>
          <source src="tracking_cam.mp4" type="video/mp4">
          Votre navigateur ne supporte pas la lecture vid√©o.
        </video>
        <div class="legend">
                    <p>Tracking activ√© vue de l'exterieur </p>
            </div> 


        <details >    
        <summary > <b style="color: red;">Programme pour Gimball et Tracking sur Python</b>
            </summary >
        <pre><button class="copy-btn" onclick="copyCode()">Copier</button><code id="code-block">    

             </code></pre>
      </details>    
      <p>
        <br>
      </p>
        <hr>

        <h3>Partie Balance</h3>

         <p>
          On apelle le script "gyro.py" en parall√®le pour les m√™mes raisons que pr√©c√©dement.
         </p>

          <p>
          La premi√®re partie du script d√©finit les param√®tres du contr√¥leur PID ainsi que les
          limites de sortie (un peu particuli√®re car on utilise des moteurs pas √† pas). Le PID utilise 
          ces valeurs pour calculer l‚Äôintensit√© de correction qui devra √™tre appliqu√©e aux moteurs 
          afin de compenser les √©carts entre la posture r√©elle et la posture cible.
          </p>

          <p>
          Dans la boucle principale, chaque it√©ration commence par la lecture d‚Äôune ligne 
          g√©n√©r√©e par le gyroscope,  si la ligne est valide, le programme extrait les valeurs 
          de roulis et de tangage, puis calcule le temps √©coul√© depuis la derni√®re mesure.
          </p>

          <p>
          Le sens de rotation des moteurs est d√©termin√© par le signe de la sortie PID : un signe positif ou n√©gatif dicte la direction que les moteurs doivent prendre pour revenir vers la position cible. Deux impulsions successives (mont√©e puis descente) sont ensuite envoy√©es aux broches STEP afin de faire avancer les moteurs, r√©p√©t√©es en continu tant que la stabilisation est n√©cessaire. Le d√©lai entre ces impulsions est ajust√© en fonction de la valeur du PID.
          </p>

          <video controls>
          <source src="/Projet/.mp4" type="video/mp4">
          Votre navigateur ne supporte pas la lecture vid√©o.
        </video>
        <div class="legend">
                    <p>feur</p>
            </div> 

            <details >    
        <summary > <b style="color: red;">Correcteur balancier sur Python</b>
            </summary >
        <pre><button class="copy-btn" onclick="copyCode()">Copier</button><code id="code-block">    

             </code></pre>
      </details>


          <div class="highlight">

          <p>
            Cependant, √† ce que l'on peut voir, la correction ne fonctionne pas tr√®s bien. Ceci est 
            d√ª √† plusieurs facteurs qui s'entrem√™lent :
            <ul>
                <li>On utilise une carte Pi donc on ne g√©n√®re pas des impulsions pr√©cises en dessous de 100 ¬µs</li>
                <li>On ne peut pas utiliser de microstepping √† cause du fait pr√©c√©dent car sinon les 
                  moteurs ne tournent pas assez vite</li>
                <li>Sans microstepping les pas sont brusques et saccad√©s (en plus de ne pas √™tre r√©guliers) 
                  ce qui induit des vibrations</li>
                <li>Les vibrations incessantes d√©r√®glent le gyroscope avec du drift qu'il est compliqu√© de corriger car il d√©pend des 
                  r√©ponses du syst√®me en lui-m√™me</li>
            </ul>
        </p>

        <p>
            Ainsi pour r√©soudre le probl√®me il faudrait changer de carte pour une Arduino (g√®re le timing
            des impulsions de mani√®re beaucoup plus pr√©cise) ou changer les moteurs pas √† pas pour des moteurs
            classiques (pour ne pas avoir de vibrations)
        </p>
          </div>


          <p>
            Le projet s'ach√®ve sur un √©chec mais √† √©t√© tr√®s formateur, il ma fait me rendre compte de l'importance
            de nombreux aspect de ce genre de syst√®me que j'avais n√©glig√©. Je referais un projet de ce type
            bientot en corrigeant ces d√©fauts et en changent les roues pour des pattes ! 
          </p>

    </main>
</div>

<footer>
    ¬© 2025 - Guillaume Dengreville
</footer>

</body>

</html>
