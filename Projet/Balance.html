<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Robot Self Balancing</title>
  <link rel="stylesheet" href="../style.css">
</head>
<body>

  <!-- Navbar dynamique -->
  <div id="navbar"></div>

  <!-- --- MathJax for LaTeX equations --- -->
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>

  <script>
  // Load navbar dynamically from external file
  fetch("navbar_projet.html")
    .then(response => response.text())  // Read the content as text
    .then(data => {
      // Insert the navbar HTML into the page
      document.getElementById("navbar").innerHTML = data;

      // ----------------------------
      // Highlight the current page
      // ----------------------------
      const currentPath = window.location.pathname;  // e.g., "/index.html"
      const links = document.querySelectorAll("#navbar nav a"); // all nav links

      links.forEach(link => {
        const href = link.getAttribute("href");
        if (!href) return; // Skip links without href

        // Normalize paths (remove leading slash) to compare properly
        const normalizedHref = href.replace(/^\//, "");
        const normalizedPath = currentPath.replace(/^\//, "");

        if (normalizedPath.endsWith(normalizedHref)) {
          // ‚úÖ Mark link of current page as active
          link.classList.add("active");

          // If the link is in a submenu, also highlight its parent
          const parentLi = link.closest("ul")?.closest("li");
          if (parentLi) {
            const parentLink = parentLi.querySelector(":scope > a");
            if (parentLink) parentLink.classList.add("active-parent");
          }
        } else {
          // Remove active class from other links
          link.classList.remove("active");
        }
      });

      // ----------------------------
      // Night mode toggle button
      // ----------------------------
      const themeToggle = document.getElementById("themeToggle");

      // On page load, check if user previously enabled night mode
      if (localStorage.getItem("nightMode") === "true") {
        document.body.classList.add("night");
        if (themeToggle) themeToggle.textContent = "‚òÄÔ∏è Day Mode";
      }

      // Set up click listener for the button
      if (themeToggle) {
        themeToggle.addEventListener("click", () => {
          document.body.classList.toggle("night"); // Toggle night mode

          // Save current mode in localStorage to persist across pages
          const isNight = document.body.classList.contains("night");
          localStorage.setItem("nightMode", isNight);

          // Update button text based on current mode
          themeToggle.textContent = isNight ? "‚òÄÔ∏è Day Mode" : "üåô Night Mode";
        });
      }
    })
    .catch(error => console.error("Erreur chargement navbar :", error));
</script>


<div class="container">
    <!-- Contenu principal -->
    <main class="content">

        <h1>
            Robot Auto Balanc√©
        </h1>

        <p>
           Dans le cadre de mes travaux en robotique, j‚Äôai souhait√© concevoir un robot mobile 
           pr√©sentant un r√©el int√©r√™t p√©dagogique. En effet, un robot mobile √† quatres roues 
           sans fonctionnalit√© sp√©cifique, offre un int√©r√™t limit√© en mati√®re d‚Äôapprentissage 
           et d‚Äôexp√©rimentation. J‚Äôai donc orient√© mon projet vers la r√©alisation d‚Äôun robot 
           auto-balanc√©, permettant d‚Äôaborder des notions avanc√©es telles que la r√©gulation 
           automatique, la stabilit√© dynamique et le contr√¥le en temps r√©el.
        </p>

        <p>
            Disposant d‚Äôune cam√©ra Raspberry Pi Module 3 inutilis√©e lors de projets pr√©c√©dents, 
            j‚Äôai √©galement choisi d‚Äôint√©grer un syst√®me de vision embarqu√©. Afin d‚Äôam√©liorer 
            la qualit√© des images et d‚Äôexploiter davantage les capacit√©s du dispositif, cette 
            cam√©ra devait √™tre mont√©e sur un stabilisateur con√ßu par mes soins lui aussi 
            permettant de compenser les mouvements du robot
        </p>  

        <div class="highlight">
        <p>
          On trouve nombre de vid√©o sur Youtube avec ce m√™me projet, qui utilise pour la plupart tous le m√™me 
          software et hardware. Pour ma part j'ai d√©cid√© de faire toute la conception et la partie logiciel moi m√™me, pour le meilleur et pour le pire.
        </p>
        </div>

        <p>
        <br>
      </p>


        <hr>

        <h3> Hardware</h3>

        <p>
            Le gimbal est √©quip√© de 2 servomoteurs
            <a href=https://www.amazon.fr/dp/B088NB5Y27?ref=ppx_yo2ov_dt_b_fed_asin_title>  MG996R</a>
            , pilot√©s par une carte driver 
            <a href=https://www.amazon.fr/dp/B0BKZC1XWR?ref=ppx_yo2ov_dt_b_fed_asin_title>  PCA9685</a>
            , et supporte une
            <a href=https://www.amazon.fr/dp/B0BRY6MVXL?ref=ppx_yo2ov_dt_b_fed_asin_title&th=1>  cam√©ra Raspberry Pi Module 3</a>
             Cette cam√©ra filme en <em>1920√ó1080</em> sans possibilit√© de r√©duire
            la r√©solution, ce qui n√©cessite une Raspberry Pi suffisamment puissante pour traiter la vid√©o.
        </p>

        <p>
            Le robot utilise une 
            <a href=https://www.amazon.fr/dp/B0CK2FCG1K?ref=ppx_yo2ov_dt_b_fed_asin_title>  Raspberry Pi 5 avec 8 Go de RAM</a>.
             Le syst√®me √©tant totalement autonome,
            tous les composants sont aliment√©s par batteries. Une 
            <a href=https://www.amazon.fr/dp/B09YCY1MX1?ref=ppx_yo2ov_dt_b_fed_asin_title&th=1>  alimentation 6 V</a>
            est d√©di√©e aux servomoteurs,
            tandis qu‚Äôune source 
            <a href=https://www.amazon.fr/dp/B0DXPWDZWQ?ref=ppx_yo2ov_dt_b_fed_asin_title>  source 12V/5A</a>
            alimente la Raspberry Pi via un
            <a href=https://www.amazon.fr/dp/B099DK7WS9?ref=ppx_yo2ov_dt_b_fed_asin_title>  abaisseur de tension</a>.
        </p>

        <p>
            La batterie 12V alimente aussi les 2 moteurs pas √† pas 
            <a href=https://www.amazon.fr/dp/B00PNEQKC0?ref=ppx_yo2ov_dt_b_fed_asin_title> NEMA 17</a>
            , contr√¥l√©s par des drivers
            <a href=https://www.amazon.fr/dp/B07C2V9GWC?ref=ppx_yo2ov_dt_b_fed_asin_title&th=1> A4988</a>,
            permettant une gestion pr√©cise du mouvement avec la possibilit√© de faire du microstepping.
        </p>

        <p>
            Pour mesurer l‚Äôorientation du robot dans l‚Äôespace (inclinaison et mouvement), un capteur 
            <a href=https://www.amazon.fr/dp/B0CLS2JY43?ref=ppx_yo2ov_dt_b_fed_asin_title> MPU6050</a>
            (gyroscope et acc√©l√©rom√®tre) est utilis√© afin de fournir les donn√©es n√©cessaires √† l‚Äô√©quilibrage.
        </p>


        <p>
        <br>
      </p>

        <hr>

        

        <h3>
            Partie Gimball & Tracking
        </h3>

        <p>
        Le programme de gimball & de tracking contr√¥le une cam√©ra mont√©e sur un syst√®me 
        Pan/Tilt motoris√© par deux servomoteurs. Il permet deux modes de fonctionnement : 
        un mode manuel avec boutons directionnels et un mode automatique o√π la cam√©ra suit 
        un objet circulaire d√©tect√© dans l‚Äôimage gr√¢ce √† la vision par ordinateur. 
        </p>

        <img src="vu_front_self.jpg" alt="Vue Face">
            <div class="legend">
                    <p>Vu de face du robot avec en haut la partie Gimball</p>
            </div> 

        <p>
        Le script commence par importer toutes les biblioth√®ques n√©cessaires : 
        gestion des servos via <em><b>ServoKit</b></em>, interface graphique via 
        <b><em>Tkinter</b></em>, capture vid√©o avec <b><em>Picamera2</b></em>, 
        traitement d‚Äôimage avec <b><em>OpenCV</b></em>, et gestion de fichiers. On 
        apelle le script "gyro.py" en parall√®le pour fournir en continu les valeurs de 
        roulis et tangage du gyroscope, √©crites dans un fichier texte.
        </p>

        <details >    
        <summary > <b style="color: red;">Programme gyroscope sur Python</b>
            </summary >
        <pre><button class="copy-btn" onclick="copyCode()">Copier</button><code id="code-block">    
import smbus2
import time
import math
import sys

# Active l'affichage imm√©diat dans le terminal (utile pour le debug)
sys.stdout.reconfigure(line_buffering=True)

# =========================================================
# === CONSTANTES DU MPU6050 ===============================
# =========================================================
MPU_ADDR = 0x68          # Adresse I2C du MPU6050
PWR_MGMT_1 = 0x6B        # Registre de gestion de l'alimentation

# Registres de sortie de l'acc√©l√©rom√®tre
ACCEL_XOUT_H = 0x3B
ACCEL_YOUT_H = 0x3D
ACCEL_ZOUT_H = 0x3F

# Registres de sortie du gyroscope
GYRO_XOUT_H = 0x43
GYRO_YOUT_H = 0x45
GYRO_ZOUT_H = 0x47

# =========================================================
# === INITIALISATION DU BUS I2C ===========================
# =========================================================
bus = smbus2.SMBus(3)           # Bus I2C 
bus.write_byte_data(MPU_ADDR, PWR_MGMT_1, 0)  # R√©veille le MPU6050
time.sleep(0.1)

# =========================================================
# === VARIABLES GLOBALES POUR LES ANGLES ==================
# =========================================================
roll = 0.0    # Rotation autour de l‚Äôaxe X
pitch = 0.0   # Rotation autour de l‚Äôaxe Y
yaw = 0.0     # Rotation autour de l‚Äôaxe Z (non utilis√© ici)

# =========================================================
# === OFFSETS DU GYROSCOPE (CALIBRATION) ==================
# =========================================================
GyroErrorX = 0.0
GyroErrorY = 0.0
GyroErrorZ = 0.0

# =========================================================
# === LECTURE D‚ÄôUNE VALEUR SIGN√âE 16 BITS =================
# =========================================================
def read_word(reg):
    """
    Lit une valeur 16 bits sign√©e √† partir d‚Äôun registre I2C
    avec gestion des erreurs de communication.
    """
    for attempt in range(5):
        try:
            high = bus.read_byte_data(MPU_ADDR, reg)
            low = bus.read_byte_data(MPU_ADDR, reg + 1)
            val = (high << 8) | low

            # Conversion en nombre sign√©
            if val >= 0x8000:
                val -= 65536
            return val

        except Exception as e:
            print(f"‚ö†Ô∏è Erreur I¬≤C {attempt+1}/5 : {e}", file=sys.stderr)
            time.sleep(0.01 * (attempt + 1))

    raise IOError("√âchec de lecture MPU6050 apr√®s plusieurs tentatives")

# =========================================================
# === CALIBRATION DE L‚ÄôIMU ================================
# =========================================================
def calibrate_imu():
    """
    Calcule les offsets du gyroscope lorsque le capteur
    est parfaitement immobile.
    """
    global GyroErrorX, GyroErrorY, GyroErrorZ

    print("Calibration IMU : ne pas bouger le capteur.", file=sys.stderr)

    gyroX_sum = gyroY_sum = gyroZ_sum = 0.0

    for _ in range(1000):
        gx = read_word(GYRO_XOUT_H) / 131.0
        gy = read_word(GYRO_YOUT_H) / 131.0
        gz = read_word(GYRO_ZOUT_H) / 131.0

        gyroX_sum += gx
        gyroY_sum += gy
        gyroZ_sum += gz

        time.sleep(0.005)

    # Moyenne des erreurs du gyroscope
    GyroErrorX = gyroX_sum / 1000.0
    GyroErrorY = gyroY_sum * 1.1 / 1000.0  # Correction empirique
    GyroErrorZ = gyroZ_sum / 1000.0

    print("Calibration termin√©e.\n", file=sys.stderr)

# =========================================================
# === LANCEMENT DE LA CALIBRATION =========================
# =========================================================
calibrate_imu()

# =========================================================
# === CALCUL DES OFFSETS D‚ÄôANGLE INITIAUX =================
# =========================================================
ax = read_word(ACCEL_XOUT_H)
ay = read_word(ACCEL_YOUT_H)
az = read_word(ACCEL_ZOUT_H)

# Angles initiaux lorsque le capteur est √† plat
roll_offset  = math.atan2(ay, az) * 180 / math.pi
pitch_offset = math.atan2(-ax, math.sqrt(ay*ay + az*az)) * 180 / math.pi

print(f"Offset Roll = {roll_offset:.2f}¬∞, Offset Pitch = {pitch_offset:.2f}¬∞",
      file=sys.stderr)

# =========================================================
# === BOUCLE PRINCIPALE ===================================
# =========================================================
previous_time = time.perf_counter()
print("Lecture des donn√©es IMU... (Ctrl+C pour arr√™ter)\n", file=sys.stderr)

alpha = 0.96  # (pr√©vu pour filtre compl√©mentaire, non utilis√© ici)

try:
    while True:
        # Calcul du temps √©coul√©
        current_time = time.perf_counter()
        dt = current_time - previous_time
        previous_time = current_time

        # =========================
        # Lecture du gyroscope
        # =========================
        gx = read_word(GYRO_XOUT_H) / 131.0 - GyroErrorX
        gy = read_word(GYRO_YOUT_H) / 131.0 - GyroErrorY
        gz = read_word(GYRO_ZOUT_H) / 131.0 - GyroErrorZ

        # =========================
        # Lecture de l‚Äôacc√©l√©rom√®tre
        # =========================
        ax = read_word(ACCEL_XOUT_H)
        ay = read_word(ACCEL_YOUT_H)
        az = read_word(ACCEL_ZOUT_H)

        # =========================
        # Calcul des angles via l‚Äôacc√©l√©rom√®tre
        # =========================
        accel_roll  = math.atan2(ay, az) * 180 / math.pi
        accel_pitch = math.atan2(-ax, math.sqrt(ay*ay + az*az)) * 180 / math.pi

        # =========================
        # Int√©gration du gyroscope
        # =========================
        roll  += gx * dt
        pitch += gy * dt

        # =========================
        # √âcriture des angles dans un fichier texte
        # =========================
        with open("/home/Documents/datagyro.txt", "w") as file:
            file.write(f"{roll:.2f},{pitch:.2f}")

        time.sleep(0.01)

except KeyboardInterrupt:
    print("\nArr√™t du programme.", file=sys.stderr)
    sys.exit(0)

             </code></pre>
      </details>

        <p>
        Ensuite, le programme configure les servomoteurs Pan et Tilt, charge les derniers 
        angles sauvegard√©s et r√©applique ces valeurs afin de restaurer la position pr√©c√©dente 
        de la cam√©ra. 
        </p>

        <p>
        On met en place l‚Äôinterface graphique Tkinter ensuite; Elle affiche le flux vid√©o en 
        direct depuis la cam√©ra et propose des boutons fl√©ch√©s permettant de contr√¥ler les 
        mouvements de la cam√©ra manuellement (lorsque l‚Äôutilisateur maintient un bouton enfonc√©, 
        la cam√©ra se d√©place continuellement dans la direction choisie). Durant ces mouvements 
        manuels, on d√©sactive la stabilisation gyroscopique est temporairement afin d‚Äô√©viter 
        des contre-mouvements ind√©sirables.
        </p>

        <video controls>
          <source src="gimball_vid.mp4" type="video/mp4">
          Votre navigateur ne supporte pas la lecture vid√©o.
        </video>
        <div class="legend">
                    <p>Gimball du robot en action</p>
            </div> 

        <p>
        La stabilisation gyroscopique fonctionne en mode manuel en lisant les valeurs du 
        gyroscope, puis en corrigeant automatiquement l‚Äôangle des servos pour compenser les 
        mouvements de la base. Cette compensation se fait en soustrayant le roulis au servo 
        Pan et en ajoutant le tangage au servo Tilt.
        </p>

        <p>
        En mode automatique, on analyse l‚Äôimage et d√©tecter un cercle gr√¢ce √† l‚Äôalgorithme de 
        HoughCircles (ou recherche de cercle par transform√© de hough en francais). Une fois 
        d√©tect√©, le plus grand des cercles visible est choisi comme cible. Le contr√¥leur 
        proportionnel calcule alors les √©carts entre la position du cercle et le centre de 
        l‚Äôimage, puis ajuste automatiquement les servos Pan et Tilt pour recentrer la cible √† l‚Äô√©cran. 
        </p>

        <video controls>
          <source src="soft_tracking.mp4" type="video/mp4">
          Votre navigateur ne supporte pas la lecture vid√©o.
        </video>
        <div class="legend">
                    <p>Fenetre Tkinter avec vu de la cam√©ra et panneau de contr√¥le</p>
            </div> 

        <p>
          Vue de l'exterieur : 
        </p>

        <video controls>
          <source src="tracking_cam.mp4" type="video/mp4">
          Votre navigateur ne supporte pas la lecture vid√©o.
        </video>
        <div class="legend">
                    <p>Tracking activ√© vue de l'exterieur </p>
            </div> 


        <details >    
        <summary > <b style="color: red;">Programme pour Gimball et Tracking sur Python</b>
            </summary >
        <pre><button class="copy-btn" onclick="copyCode()">Copier</button><code id="code-block">    
import time
import numpy as np
from adafruit_servokit import ServoKit
import tkinter as tk
from PIL import Image, ImageTk
from picamera2 import Picamera2
import cv2
import os
import subprocess

# =====================
# Param√®tres Mat√©riels
# =====================
# Lancement du script gyroscope externe qui √©crit les donn√©es dans un fichier
p1 = subprocess.Popen(["sudo", "python3", "/home /Documents/gyro.py"])

# Initialisation du module PCA9685 pour contr√¥ler les servos
kit = ServoKit(channels=16)
servo_channels = [0, 1]  # Servo 0 = Pan (gauche/droite), Servo 1 = Tilt (haut/bas)

# Limites physiques des servos et pas d'incr√©ment
ANGLE_MIN = 0
ANGLE_MAX = 180
STEP_DEG = 1

# Fichiers de stockage des angles
ANGLE_FILE = "/home/Documents/angle_cam.txt"
REF_SERVO = "/home/Documents/gyro_ref.txt"
GYRO_LIVE = "/home/Documents/datagyro.txt"

gyro_active = True  # Active la stabilisation gyroscopique

# =====================
# Fonctions Utilitaires
# =====================

def read_angles_gyro():
    """Lit roll et pitch depuis le fichier du gyroscope."""
    try:
        with open(GYRO_LIVE) as f:
            line = f.read().strip()
        if not line or "," not in line:
            return None
        roll, pitch = map(float, line.split(","))
        return roll, pitch
    except Exception as e:
        print("Erreur lecture gyro:", e)
        return None


def read_angle_file(path):
    """Lit les angles pan/tilt depuis un fichier, valeur par d√©faut = 90/90."""
    try:
        with open(path, "r") as f:
            lines = [float(l.strip()) for l in f.readlines() if l.strip()]
        if len(lines) < 2:
            raise ValueError("Le fichier doit contenir deux valeurs")
        return [np.clip(lines[0], ANGLE_MIN, ANGLE_MAX),
                np.clip(lines[1], ANGLE_MIN, ANGLE_MAX)]
    except Exception:
        return [90.0, 90.0]


def write_angle_file(path, angles):
    """√âcrit les angles pan/tilt dans un fichier texte."""
    try:
        dirname = os.path.dirname(path)
        if dirname and not os.path.exists(dirname):
            os.makedirs(dirname)
        with open(path, "w") as f:
            f.write(f"{angles[0]}\n{angles[1]}\n")
    except Exception as e:
        print("Erreur √©criture fichier angles:", e)


def apply_angles(angles):
    """Applique les angles aux servos (pan et tilt)."""
    for i, a in enumerate(angles):
        try:
            kit.servo[servo_channels[i]].angle = float(np.clip(a, ANGLE_MIN, ANGLE_MAX))
        except Exception as e:
            print(f"Impossible de r√©gler le servo {servo_channels[i]}: {e}")

# Initialisation position
lines_next = read_angle_file(ANGLE_FILE)
write_angle_file(ANGLE_FILE, lines_next)
write_angle_file(REF_SERVO, lines_next)  # r√©f√©rence pour le gyro
apply_angles(lines_next)

# Configuration optionnelle des pulses des servos
try:
    for ch in servo_channels:
        if hasattr(kit.servo[ch], "set_pulse_width_range"):
            kit.servo[ch].set_pulse_width_range(600, 3400)
except Exception as e:
    print("Avertissement configuration pulse:", e)

# =====================
# √âtats Globaux
# =====================
mode_auto = False  # False = manuel, True = suivi automatique
move_job = None     # Gestion Tkinter du mouvement manuel
track_job = None    # Gestion Tkinter du tracking

# =====================
# Cam√©ra
# =====================
picam2 = Picamera2()
config = picam2.create_preview_configuration(main={"size": (640, 480)})
picam2.configure(config)
picam2.start()

# =====================
# Interface Tkinter
# =====================
root = tk.Tk()
root.title("Contr√¥le Cam√©ra + Servos")
root.geometry("720x880")

frame = tk.Frame(root, padx=12, pady=12)
frame.pack()

status_label = tk.Label(root, text="Mode manuel actif ‚Äî utilisez les fl√®ches", anchor="w")
status_label.pack(fill="x", padx=12, pady=(0, 8))

video_label = tk.Label(root)
video_label.pack(pady=10)

# Boutons de contr√¥le manuel
key_to_button = {}
buttons_info = [
    ("‚Üë", "Up", 0, 1),
    ("‚Üì", "Down", 2, 1),
    ("‚Üê", "Left", 1, 0),
    ("‚Üí", "Right", 1, 2)
]

def set_buttons_state(state: str):
    """Active/d√©sactive tous les boutons de mouvement."""
    for btn in key_to_button.values():
        btn.config(state=state)

# =====================
# Mouvement Manuel
# =====================
def start_move(direction):
    """D√©marre un mouvement r√©p√©t√© tant que le bouton est maintenu."""
    global move_job, lines_next, gyro_active
    gyro_active = False  # d√©sactivation temporaire du gyro

    def move():
        global lines_next, move_job
        pan, tilt = lines_next

        # Ajustements selon direction
        if direction == "Up":
            tilt -= STEP_DEG
        elif direction == "Down":
            tilt += STEP_DEG
        elif direction == "Left":
            pan += STEP_DEG
        elif direction == "Right":
            pan -= STEP_DEG

        # Limites s√©curis√©es
        pan = float(np.clip(pan, ANGLE_MIN + 5, ANGLE_MAX - 5))
        tilt = float(np.clip(tilt, ANGLE_MIN + 5, ANGLE_MAX - 5))

        lines_next = [pan, tilt]
        apply_angles(lines_next)
        write_angle_file(ANGLE_FILE, lines_next)
        write_angle_file(REF_SERVO, lines_next)  # mise √† jour pour gyro

        move_job = root.after(50, move)  # r√©p√©tition toutes les 50 ms

    stop_move()
    move()


def stop_move(event=None):
    """Arr√™te le mouvement manuel."""
    global move_job, gyro_active
    if move_job is not None:
        root.after_cancel(move_job)
        move_job = None
    gyro_active = True

# Cr√©ation des boutons
for symbol, name, row, col in buttons_info:
    btn = tk.Button(frame, text=f"[{name.upper()}] {symbol}", width=10, height=2)
    btn.grid(row=row, column=col, padx=6, pady=6)
    key_to_button[name] = btn
    btn.bind("<ButtonPress-1>", lambda e, d=name: start_move(d))
    btn.bind("<ButtonRelease-1>", stop_move)

# =====================
# Suivi Automatique via d√©tection de cercle
# =====================
TAILLE_IRL_MM = 122.5
FOCALE_MM = 4.74
PIXEL_SIZE_MM = 0.003828

def start_tracking_loop():
    """Boucle de suivi automatique : d√©tecte un cercle et recentre la cam√©ra."""
    global track_job, lines_next

    def track():
        global track_job, lines_next
        frame = picam2.capture_array()
        frame_bgr = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)
        h, w = frame_bgr.shape[:2]
        Cx, Cy = w / 2, h / 2  # centre √©cran

        # Pr√©-traitement pour HoughCircles
        gray = cv2.cvtColor(frame_bgr, cv2.COLOR_BGR2GRAY)
        blur = cv2.GaussianBlur(gray, (9, 9), 2)

        # D√©tection de cercles
        circles = cv2.HoughCircles(blur, cv2.HOUGH_GRADIENT, 1, h / 8,
                                   param1=100, param2=50,
                                   minRadius=1, maxRadius=200)
        display = frame.copy()

        if circles is not None:
            circles = np.uint16(np.around(circles))
            best = sorted(circles[0, :], key=lambda c: c[2], reverse=True)[0]
            cx, cy, radius = int(best[0]), int(best[1]), int(best[2])

            # Dessin du cercle d√©tect√©
            cv2.circle(display, (cx, cy), 1, (0, 100, 100), 3)
            cv2.circle(display, (cx, cy), radius, (255, 0, 255), 3)
            cv2.drawMarker(display, (int(Cx), int(Cy)), (0, 0, 255), cv2.MARKER_CROSS, 20, 2)

            # Contr√¥leur proportionnel : corrige la position
            Kp_pan, Kp_tilt = 0.02, 0.02
            pan, tilt = lines_next
            pan_delta = (cx - Cx) * Kp_pan
            tilt_delta = (cy - Cy) * Kp_tilt

            pan_new = float(np.clip(pan - pan_delta, ANGLE_MIN + 5, ANGLE_MAX - 5))
            tilt_new = float(np.clip(tilt + tilt_delta, ANGLE_MIN + 5, ANGLE_MAX - 5))

            lines_next = [pan_new, tilt_new]
            apply_angles(lines_next)
            write_angle_file(ANGLE_FILE, lines_next)

        # Affichage vid√©o
        display_rgb = cv2.cvtColor(display, cv2.COLOR_BGR2RGB)
        img = ImageTk.PhotoImage(Image.fromarray(display_rgb))
        video_label.config(image=img)
        video_label.image = img

        track_job = root.after(60, track)

    stop_tracking()
    track()

def stop_tracking():
    """Arr√™te la boucle de suivi automatique."""
    global track_job
    if track_job is not None:
        root.after_cancel(track_job)
        track_job = None

# =====================
# Changement de Mode
# =====================
def switch_mode():
    """Active/d√©sactive le mode suivi automatique."""
    global mode_auto
    mode_auto = not mode_auto

    if mode_auto:
        set_buttons_state("disabled")
        mode_button.config(text="Mode: SUIVI", bg="orange")
        status_label.config(text="Mode suivi actif ‚Äî contr√¥le manuel d√©sactiv√©")
        start_tracking_loop()
    else:
        set_buttons_state("normal")
        mode_button.config(text="Mode: MANUEL", bg="lightblue")
        status_label.config(text="Mode manuel actif ‚Äî utilisez les fl√®ches")
        stop_tracking()

# =====================
# Gestion du Gyro + Preview
# =====================
def update_frame_preview():
    """Affiche la vid√©o en mode manuel + applique la stabilisation gyro."""
    if not mode_auto:
        frame = picam2.capture_array()
        img = ImageTk.PhotoImage(Image.fromarray(frame))
        video_label.config(image=img)\


             </code></pre>
      </details>    
      <p>
        <br>
      </p>
        <hr>

        <h3>Partie Balance</h3>

         <p>
          On apelle le script "gyro.py" en parall√®le pour les m√™mes raisons que pr√©c√©dement.
         </p>

          <p>
          La premi√®re partie du script d√©finit les param√®tres du contr√¥leur PID ainsi que les
          limites de sortie (un peu particuli√®re car on utilise des moteurs pas √† pas). Le PID utilise 
          ces valeurs pour calculer l‚Äôintensit√© de correction qui devra √™tre appliqu√©e aux moteurs 
          afin de compenser les √©carts entre la posture r√©elle et la posture cible.
          </p>

          <p>
          Dans la boucle principale, chaque it√©ration commence par la lecture d‚Äôune ligne 
          g√©n√©r√©e par le gyroscope,  si la ligne est valide, le programme extrait les valeurs 
          de roulis et de tangage, puis calcule le temps √©coul√© depuis la derni√®re mesure.
          </p>

          <p>
          Le sens de rotation des moteurs est d√©termin√© par le signe de la sortie PID : un signe positif ou 
            n√©gatif dicte la direction que les moteurs doivent prendre pour revenir vers la position cible. 
            Deux impulsions successives (mont√©e puis descente) sont ensuite envoy√©es aux broches STEP afin de 
            faire avancer les moteurs, r√©p√©t√©es en continu tant que la stabilisation est n√©cessaire. 
            Le d√©lai entre ces impulsions est ajust√© en fonction de la valeur du PID.
          </p>

            <details >    
        <summary > <b style="color: red;">Correcteur balancier sur Python</b>
            </summary >
        <pre><button class="copy-btn" onclick="copyCode()">Copier</button><code id="code-block">    
import lgpio
import time
import subprocess
import smbus2
import math
import sys

# Lancement du script gyro.py en parall√®le.
# Ce script √©crit en continu les valeurs 'roll,pitch' sur la sortie standard.
proc = subprocess.Popen(
    ['python3', '/home/Documents/gyro.py'],
    stdout=subprocess.PIPE,
    text=True,
    bufsize=1  # mode ligne par ligne
)

# --- Param√®tres PID ---
obj = 0              # valeur cible (pitch = 0¬∞)
Kp = 3               # gain proportionnel
Kd = 0.1             # gain d√©riv√©
Ki = 10              # gain int√©gral

u = 0                # sortie du PID
u_max = 100          # saturation maximale
vitesse = 0          # temps entre impulsions step
integral = 0         # m√©moire int√©grale
past_err = 0         # erreur pr√©c√©dente
maxSpeed = 0.001     # vitesse maximale
minSpeed = 0.01      # vitesse minimale

# --- D√©finition des broches ---
# Deux moteurs pas-√†-pas, chacun avec STEP, DIR, ENABLE
stepPin1 = 24
dirPin1 = 23
enPin1 = 25

stepPin2 = 4
dirPin2 = 27
enPin2 = 22

# --- Initialisation du contr√¥leur GPIO (lgpio) ---
chip = lgpio.gpiochip_open(0)

# Configuration des broches comme sorties
for pin in [stepPin1, dirPin1, enPin1, stepPin2, dirPin2, enPin2]:
    lgpio.gpio_claim_output(chip, pin)

# Activation des moteurs 
lgpio.gpio_write(chip, enPin1, 1)
lgpio.gpio_write(chip, enPin2, 1)
 time.sleep(0.1)
lgpio.gpio_write(chip, enPin1, 0)
lgpio.gpio_write(chip, enPin2, 0)

# Pause avant la boucle principale
time.sleep(10)
previousTime = time.perf_counter()

try:
    while True:
        # Lecture d'une ligne envoy√©e par gyro.py
        line = proc.stdout.readline()
        if not line:
            continue  # pas encore de donn√©es

        # Extraction des valeurs roll et pitch
        try:
            roll, pitch = map(float, line.strip().split(','))
        except ValueError:
            continue  # ligne invalide

        # Mesure du temps √©coul√© pour le PID
        currentTime = time.perf_counter()
        dt = currentTime - previousTime
        previousTime = currentTime

        # ------ PID ------
        # Erreur = consigne - mesure 
        err = obj - pitch 

        # Int√©grale : somme cumul√©e des erreurs
        integral += err * dt

        # D√©riv√©e : variation de l'erreur
        derivative = (err - past_err) / dt
        past_err = err

        # Calcul de la commande PID
        u = Kp * err + Ki * integral + Kd * derivative

        # Saturation
        if u > u_max:
            u = u_max
        elif u < -u_max:
            u = -u_max

        # Si l'erreur est faible, arr√™ter les moteurs (deadband)
        if abs(err) < 0.2:
            previousTime = currentTime
            continue

        # Conversion de u en vitesse d'impulsion des moteurs
        vitesse = (1 - (abs(u) / u_max)) * (minSpeed - maxSpeed) + maxSpeed

        # Choix du sens de rotation pour corriger le pitch
        if u > 0:
            lgpio.gpio_write(chip, dirPin1, 0)
            lgpio.gpio_write(chip, dirPin2, 0)
        else:
            lgpio.gpio_write(chip, dirPin1, 1)
            lgpio.gpio_write(chip, dirPin2, 1)

        # Envoi des impulsions STEP (d√©placement)
        lgpio.gpio_write(chip, stepPin1, 1)
        lgpio.gpio_write(chip, stepPin2, 1)
        time.sleep(abs(vitesse))

        lgpio.gpio_write(chip, stepPin1, 0)
        lgpio.gpio_write(chip, stepPin2, 0)
        time.sleep(abs(vitesse))

except KeyboardInterrupt:
    print("Arr√™t demand√© par l'utilisateur.")
	
finally:
    # D√©sactivation s√©curis√©e des moteurs
    lgpio.gpio_write(chip, stepPin1, 0)
    lgpio.gpio_write(chip, dirPin1, 0)
    lgpio.gpio_write(chip, enPin1, 1)

    lgpio.gpio_write(chip, stepPin2, 0)
    lgpio.gpio_write(chip, dirPin2, 0)
    lgpio.gpio_write(chip, enPin2, 1)

    # Lib√©ration du bus GPIO
    lgpio.gpiochip_close(chip)
    print("GPIO lib√©r√© et moteurs d√©sactiv√©s.")

             </code></pre>
      </details>


          <div class="highlight">

          <p>
            Le partie balancier du projet est en pause. En effet la correction ne fonctionne pas tr√®s bien. C'est 
            d√ª √† plusieurs facteurs qui s'entrem√™lent :
            <ul>
                <li>On utilise une carte Pi donc on ne g√©n√®re pas des impulsions pr√©cises en dessous de 100 ¬µs</li>
                <li>On ne peut pas utiliser de microstepping √† cause du fait pr√©c√©dent car sinon les 
                  moteurs ne tournent pas assez vite</li>
                <li>Sans microstepping les pas sont brusques et saccad√©s (en plus de ne pas √™tre r√©guliers) 
                  ce qui induit des vibrations</li>
                <li>Les vibrations incessantes d√©r√®glent le gyroscope avec du drift qu'il est compliqu√© de corriger car il d√©pend des 
                  r√©ponses du syst√®me en lui-m√™me</li>
            </ul>
        </p>

        <p>
            Ainsi pour r√©soudre le probl√®me il faudrait changer de carte pour une Arduino (g√®re le timing
            des impulsions de mani√®re beaucoup plus pr√©cise) ou changer les moteurs pas √† pas pour des moteurs
            classiques (pour ne pas avoir de vibrations)
        </p>
          </div>


    </main>
</div>

<footer>
    ¬© 2025 - Guillaume Dengreville
</footer>

</body>

</html>



